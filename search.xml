<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Go Modules 项目构建]]></title>
    <url>%2F2019%2F10%2F06%2Fgomod%2F</url>
    <content type="text"><![CDATA[Go 项目构建 关于 Go Modules Golang的包管理 go modules随着golang 1.11的发布而和我们见面了，这是官方提倡的新的包管理，乃至项目管理机制，可以不再需要GOPATH的存在。 初始化项目1go mod init [module name] 这样就快速通过 go modules 构建一个 Go 项目了]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang 安装]]></title>
    <url>%2F2019%2F10%2F06%2Fgolang-install%2F</url>
    <content type="text"><![CDATA[Golang 安装 官方下载地址 https://golang.org/dl/ 第三方下载地址 https://studygolang.com/dl]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS Linux 7安全基线检查]]></title>
    <url>%2F2019%2F05%2F18%2Fsafe%2F</url>
    <content type="text"><![CDATA[CentOS Linux 7安全基线检查 CentOS Linux 7安全基线检查 确保rsyslog服务已启用 | 安全审计 描述 确保rsyslog服务已启用，记录日志用于审计 检查提示 – 加固建议 运行以下命令启用rsyslog服务 systemctl enable rsyslog 确保SSH LogLevel设置为INFO | 服务配置 描述 确保SSH LogLevel设置为INFO,记录登录和注销活动 检查提示 -- 加固建议 编辑 /etc/ssh/sshd_config 文件以按如下方式设置参数(取消注释): LogLevel INFO 访问控制配置文件的权限设置 | 文件权限 描述 访问控制配置文件的权限设置 检查提示 -- 加固建议 运行以下4条命令： chown root:root /etc/hosts.allow chown root:root /etc/hosts.deny chmod 644 /etc/hosts.deny chmod 644 /etc/hosts.allow 设置用户权限配置文件的权限 | 文件权限 描述 设置用户权限配置文件的权限 检查提示 -- 加固建议 执行以下5条命令 chown root:root /etc/passwd /etc/shadow /etc/group /etc/gshadow chmod 0644 /etc/group chmod 0644 /etc/passwd chmod 0400 /etc/shadow chmod 0400 /etc/gshadow 开启地址空间布局随机化 | 入侵防范 描述 它将进程的内存空间地址随机化来增大入侵者预测目的地址难度，从而降低进程被成功入侵的风险 检查提示 -- 加固建议 执行命令： sysctl -w kernel.randomize_va_space=2 确保root是唯一的UID为0的帐户 | 身份鉴别 描述 除root以外其他UID为0的用户都应该删除，或者为其分配新的UID 检查提示 -- 加固建议 除root以外其他UID为0的用户(查看命令cat /etc/passwd | awk -F: ‘($3 == 0) { print $1 }’|grep -v ‘^root$’ )都应该删除，或者为其分配新的UID 密码复杂度检查 | 身份鉴别 描述 检查密码长度和密码是否使用多种字符类型 检查提示 -- 加固建议 编辑/etc/security/pwquality.conf，把minlen（密码最小长度）设置为9-32位，把minclass（至少包含小写字母、大写字母、数字、特殊字符等4类字符中等3类或4类）设置为3或4。如： minlen=10 minclass=3 检查系统空密码账户 | 身份鉴别 描述 检查系统空密码账户 检查提示 -- 加固建议 为用户设置一个非空密码 设置密码修改最小间隔时间 | 身份鉴别 描述 设置密码修改最小间隔时间，限制密码更改过于频繁 检查提示 -- 加固建议 在 /etc/login.defs 中将 PASS_MIN_DAYS 参数设置为7-14之间,建议为7： PASS_MIN_DAYS 7 需同时执行命令为root用户设置： chage –mindays 7 root 设置密码失效时间 | 身份鉴别 描述 设置密码失效时间，强制定期修改密码，减少密码被泄漏和猜测风险，使用非密码登陆方式(如密钥对)请忽略此项。 检查提示 -- 加固建议 使用非密码登陆方式如密钥对，请忽略此项。在 /etc/login.defs 中将 PASS_MAX_DAYS 参数设置为 60-180之间，如 PASS_MAX_DAYS 90。需同时执行命令设置root密码失效时间： chage –maxdays 90 root。 设置SSH空闲超时退出时间 | 服务配置 描述 设置SSH空闲超时退出时间,可降低未授权用户访问其他用户ssh会话的风险 检查提示 -- 加固建议 编辑/etc/ssh/sshd_config，将ClientAliveInterval 设置为300到900，即5-15分钟，将ClientAliveCountMax设置为0。 ClientAliveInterval 900 ClientAliveCountMax 0 SSHD强制使用V2安全协议 | 服务配置 描述 SSHD强制使用V2安全协议 检查提示 -- 加固建议 编辑 /etc/ssh/sshd_config 文件以按如下方式设置参数： Protocol 2 确保SSH MaxAuthTries设置为3到6之间 | 服务配置 描述 设置较低的Max AuthTrimes参数将降低SSH服务器被暴力攻击成功的风险。 检查提示 -- 加固建议 在/etc/ssh/sshd_config中取消MaxAuthTries注释符号#，设置最大密码尝试失败次数3-6，建议为4： MaxAuthTries 4 确保密码到期警告天数为7或更多 | 身份鉴别 描述 确保密码到期警告天数为7或更多 检查提示 -- 加固建议 在 /etc/login.defs 中将 PASS_WARN_AGE 参数设置为7-14之间，建议为7： PASS_WARN_AGE 7 。同时执行命令使root用户设置生效： chage –warndays 7 root 禁止SSH空密码用户登录 | 服务配置 描述 禁止SSH空密码用户登录 检查提示 -- 加固建议 在/etc/ssh/sshd_config中取消PermitEmptyPasswords no注释符号# 检查密码重用是否受限制 | 身份鉴别 描述 强制用户不重用最近使用的密码，降低密码猜测攻击风险 检查提示 -- 加固建议 在/etc/pam.d/password-auth和/etc/pam.d/system-auth中password sufficient pam_unix.so 这行的末尾配置remember参数为5-24之间，原来的内容不用更改。如下面只在末尾加了remember=5，即可限制不能重用最近5个密码。 password sufficient pam_unix.so sha512 try_first_pass remember=5 Redis安全基线检查 redis-server监听配置 | 服务配置 描述 Redis监听在0.0.0.0，可能导致服务对外或内网横向移动渗透风险，极易被黑客利用入侵。 检查提示 -- 加固建议 Redis监听在0.0.0.0，可能导致服务对外或内网横向移动渗透风险，极易被黑客利用入侵，建议监听在: 127.0.0.1或内网地址。如业务需要监听外网，请配置防火墙安全策略。 Memcached安全基线检查 Memcached启动权限检测 | 访问控制 描述 检测Memcached是否以权限启动 检查提示 -- 加固建议 创建memcached低权限账号（例如：useradd memcached），并在memcached启动时加上-u memcached。注意：在切换低权限账户启动时，需要将memcached文件目录使用chown -R memcached:memcached修改上述目录权限 Memcached udp监听检测 | 服务配置 描述 Memcached udp监听检测,检测是否监听在0.0.0.0 检查提示 -- 加固建议 重新启动memcached 加入 -U 0启动参数，例如：memcached -U 0，禁止监听在udp协议上 FTP匿名登录配置检测 Ftp匿名登录 | 身份鉴别 描述 检查是否允许匿名登陆FTP。 检查提示 -- 加固建议 建议关闭Ftp匿名登录 Linux系统登录弱口令检测 Linux系统账号弱口令 | 身份鉴别 描述 检测Linux系统登录账号常见弱口令，及SSH登录的密码是否常见弱口令 检查提示 -- 加固建议 该帐号发现弱密码，为了保证系统不被黑客恶意猜解入侵，请修改为12位以上，数字/字母/特殊字符组合的强密码 FTP登陆弱口令检测 FTP弱口令 | 身份鉴别 描述 检查FTP服务是否存在弱密码用户 检查提示 -- 加固建议 该帐号发现弱密码，请修改为12位以上，数字/字母/特殊字符组合的强密码 Apache Tomcat 安全基线检查 开启日志记录 | 安全审计 描述 Tomcat需要保存输出日志，以便于排除错误和发生安全事件时，进行分析和定位 检查提示 -- 加固建议 1、修改Tomcat根目录下的conf/server.xml文件。 2、取消Host节点下Valve节点的注释(如没有则添加)。 3、重新启动Tomcat 禁止显示异常调试信息 | 服务配置 描述 当请求处理期间发生运行时错误时，ApacheTomcat将向请求者显示调试信息。建议不要向请求者提供此类调试信息。 检查提示 -- 加固建议 在Tomcat根目录下的conf/web.xml文件里面的web-app添加子节点：java.lang.Throwable/error.jsp，在webapps目录下创建error.jsp，定义自定义错误信息 禁止Tomcat显示目录文件列表 | 服务配置 描述 Tomcat允许显示目录文件列表会引发目录遍历漏洞 检查提示 -- 加固建议 修改Tomcat 跟目录下的配置文件conf/web.xml，将listings的值设置为false。 listings false 禁止自动部署 | 服务配置 描述 配置自动部署，容易被部署恶意或未经测试的应用程序，应将其禁用 检查提示 -- 加固建议 修改Tomcat 跟目录下的配置文件conf/server.xml，将host节点的autodeploy属性设置为“false”，如果host的deploystartup属性(没有可以忽略)为“true”，则也将其更改为“false” 限制服务器平台信息泄漏 | 服务配置 描述 限制服务器平台信息泄漏会使攻击者更难确定哪些漏洞会影响服务器平台。 检查提示 -- 加固建议 1、进入Tomcat安装主目录的lib目录下，比如 cd /usr/local/tomcat7/lib 2、执行：jar xf catalina.jar org/apache/catalina/util/ServerInfo.properties，修改文件ServerInfo.properties中的server.info和server.number的值，如分别改为：Apache/11.0.92、11.0.92.0 3、执行：jar uf catalina.jar org/apache/catalina/util/ServerInfo.properties 4、重启Tomcat服务 删除项目无关文件和目录 | 访问控制 描述 Tomcat安装提供了示例应用程序、文档和其他可能不用于生产程序及目录，存在极大安全风险，建议移除 检查提示 -- 加固建议 请删除Tomcat示例程序和目录、管理控制台等，即从Tomcat根目录的webapps目录，移出或删除docs、examples、host-manager、manager目录。 Tomcat目录权限检测 | 访问控制 描述 在运行Tomcat服务时，避免使用root用户运行，tomcat目录(catalina.home、 catalina.base目录)所有者应改为非root的运行用户 检查提示 -- 加固建议 使用chown -R &lt;Tomcat启动用户所属组&gt;:&lt;Tomcat启动用户&gt; &lt;Tomcat目录&gt;修改tomcat目录文件所有者，如chown -R tomcat:tomcat /usr/local/tomcat Tomcat进程运行权限检测 | 访问控制 描述 在运行Internet服务时，最好尽可能避免使用root用户运行，降低攻击者拿到服务器控制权限的机会。 检查提示 -- 加固建议 创建低权限的账号运行Tomcat #]]></content>
      <categories>
        <category>safe</category>
      </categories>
      <tags>
        <tag>safe</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于 Docker 搭建 Nginx]]></title>
    <url>%2F2019%2F03%2F18%2Fdockerwithnginx%2F</url>
    <content type="text"><![CDATA[基于 Docker 搭建 Nginx 基于 Docker 搭建 Nginx Docker安装基于安装Docker-ce 先搜索Nginx的镜像 使用1docker pull nginx 拉取官方镜像。 使用 1docker container run 启动容器 1234567docker container run \-d \-p 80:80 \-p 443:443 \--name nginx \--rm \nginx 1234567-d : 后台运行-p ：容器的80端口映射到80 --rm：容器停止运行后，自动删除容器文件 --name：容器的名字为nginx 启动成功 关闭 1docker container stop nginx Tips：注意stop后面加的是对应的容器名或者ID 映射目录 网页文件都在容器里，没法直接修改，显然很不方便。下一步就是让网页文件所在的目录/usr/share/nginx/html映射到本地。 首先，新建一个目录，并进入该目录。 1234mkdir /usr/share/nginxmkdir /usr/share/nginx/html# 进入html文件夹cd /usr/share/nginx/html 在这个子目录里面，放置一个index.html文件，内容如下。 1&lt;h1&gt;Hello World&lt;/h1&gt; 接着，就可以把这个子目录html，映射到容器的网页文件目录/usr/share/nginx/html。 1234567docker container run \-d \-p 80:80 \-p 443:443 \--rm \--name nginx \nginx 打开浏览器，访问 对应IP，应该就能看到 Hello World 了。 拷贝配置 修改网页文件还不够，还要修改 Nginx 的配置文件，否则后面没法加 SSL 支持。 首先，把容器里面的 Nginx 配置文件拷贝到本地。 1docker container cp nginx:/etc/nginx . 上面命令的含义是，把nginx容器的/etc/nginx拷贝到当前目录。不要漏掉最后那个点。 执行完成后，当前目录应该多出一个nginx子目录。然后，把这个子目录改名为conf。 1mv nginx conf 现在可以把容器终止了。 1docker container stop nginx 映射配置目录 重新启动一个新的容器，这次不仅映射网页目录，还要映射配置目录。 Tips：注意退回到nginx目录下，目录下是conf和html两个文件夹 123456789docker container run \-d \-p 80:80 \-p 443:443 \--volume &quot;$PWD/html&quot;:/usr/share/nginx/html \--volume &quot;$PWD/conf&quot;:/etc/nginx \--rm \--name nginx \nginx 上面代码中，–volume “$PWD/conf”:/etc/nginx表示把容器的配置目录/etc/nginx，映射到本地的conf子目录。 浏览器访问对应 IP，如果能够看到网页，就说明本地的配置生效了。这时，可以把这个容器终止。 1docker container stop nginx 自签名证书 现在要为容器加入 HTTPS 支持，第一件事就是生成私钥和证书。正式的证书需要证书当局（CA）的签名，这里是为了测试，搞一张自签名（self-signed）证书就可以了。 1234567sudo openssl req \-x509 \-nodes \-days 365 \-newkey rsa:2048 \-keyout example.key \-out example.crt 上面命令的各个参数含义如下。 1234567req：处理证书签署请求。-x509：生成自签名证书。-nodes：跳过为证书设置密码的阶段，这样 Nginx 才可以直接打开证书。-days 365：证书有效期为一年。-newkey rsa:2048：生成一个新的私钥，采用的算法是2048位的 RSA。-keyout：新生成的私钥文件为当前目录下的example.key。-out：新生成的证书文件为当前目录下的example.crt。 执行后，命令行会跳出一堆问题要你回答，比如你在哪个国家、你的 Email 等等。 其中最重要的一个问题是 Common Name，正常情况下应该填入一个域名，这里可以填 127.0.0.2。 回答完问题，当前目录应该会多出两个文件：example.key和example.crt。 conf目录下新建一个子目录certs，把这两个文件放入这个子目录。 12mkdir conf/certsmv example.crt example.key conf/certs HTTPS 配置 有了私钥和证书，就可以打开 Nginx 的 HTTPS 了。 首先，打开conf/conf.d/yourrepo.conf文件,添加下面的配置。 1234567891011121314151617181920212223242526server &#123; listen 80; #listen [::]:80; server_name youdomain.com; return 301 https://$server_name$request_uri; &#125; server &#123; listen 443 ssl http2; #listen [::]:443 ssl http2; server_name youdomain.com; ssl on; ssl_certificate /etc/nginx/certs/example.crt; ssl_certificate_key /etc/nginx/certs/example.key; ssl_session_timeout 5m; ssl_protocols TLSv1.3 TLSv1.2; ssl_prefer_server_ciphers on; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; location / &#123; root /usr/share/nginx/html; index index.html index.htm; &#125; &#125; 然后，启动一个新的 Nginx 容器。 打开浏览器，访问对应 IP 。因为使用了自签名证书，浏览器会提示不安全。不要去管它，选择继续访问，应该就可以看到 Hello World 了。 至此，Nginx 容器的 HTTPS 支持就做好了。]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装Docker-ce]]></title>
    <url>%2F2019%2F03%2F01%2Finstalldockerce%2F</url>
    <content type="text"><![CDATA[安装Docker-ce 安装与使用Docker-ce 依赖的基础环境 64 bits CPU Linux Kernel 3.10+ Linux Kernel cgroups and namespaces CentOS 7 “Extras” repository Docker Daemon systemctl start docker.service Docker Client docker [OPTIONS] COMMAND [args…] 显示所有已启用的存储库 1yum repolist Tips：docker存在extras仓库中。 查看docker在这个仓库中的版本 清华大学开源软件镜像站-CnetOS7-extras下的包 Tips：通常不用这个安装 下载docker-ce的docker-ce.repo docker-ce.repo 1wget https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/centos/docker-ce.repo 修改docker-ce.repo文件 Tips：通常情况下下载的源是download.docker.com，我们需要换成清华开源软件镜像的下载源。 docker-ce的列表 1vim docker-ce.repo 配置如下： 1:%s@https://download.docker.com/@https://mirrors.tuna.tsinghua.edu.cn/docker-ce/@ 再次查看仓库 1yum repolist 下载docker-ce 1yum install docker-ce Tips：注意是docker-ce不是docker，如果输入docker下载的是extras仓库里的。 配置docker-ce的配置文件 注册阿里云账号，专用加速器地址获得路径 https://cr.console.aliyun.com/#/accelerator 配置如下： 1mkdir /etc/docker 1vim /etc/docker/daemon.json 123&#123; &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;]&#125; Tips：此处是docker cn的加速器地址。 启动docker-ce 1systemctl start docker.service 查看docker版本 安装成功！！！]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Listener 和 Filter]]></title>
    <url>%2F2019%2F02%2F15%2Flistenerandfilter%2F</url>
    <content type="text"><![CDATA[Listener 和 Filter Listener &amp; FilterListener 监听器 能做什么事？ 监听某一个事件的发生。 状态的改变。 监听器的内部机制 其实就是接口回调. 接口回调 需求： A在执行循环，当循环到5的时候， 通知B。 事先先把一个对象传递给 A ， 当A 执行到5的时候，通过这个对象，来调用B中的方法。 但是注意，不是直接传递B的实例，而是传递一个接口的实例过去。 Web监听器 总共有8个 划分成三种类型 定义一个类，实现接口 注册 | 配置监听器 监听三个作用域创建和销毁 request ---httpServletRequest session ---httpSession aapplication --- ServletContext 1. ServletContextListener servletcontext创建： 1. 启动服务器的时候 servletContext销毁： 2. 关闭服务器. 从服务器移除项目 2. ServletRequestListener request创建: 访问服务器上的任意资源都会有请求出现。 访问 html： 会 访问 jsp: 会 访问 servlet : 会 request销毁： 服务器已经对这次请求作出了响应。 public class MyRequestListener implements ServletRequestListener { @Override public void requestDestroyed(ServletRequestEvent sre) { System.out.println(&quot;servletrequest 销毁了&quot;); } @Override public void requestInitialized(ServletRequestEvent sre) { System.out.println(&quot;servletrequest 初始化了&quot;); } } ​ com.domain.listener.MyRequestListener ​ 3. HttpSessionListener session的创建 只要调用getSession html: 不会 jsp: 会 getSession(); servlet: 会 session的销毁 超时 30分钟 非正常关闭 销毁 正常关闭服务器(序列化) public class MySessionListener implements HttpSessionListener { @Override public void sessionCreated(HttpSessionEvent se) { System.out.println(&quot;创建session了&quot;); } @Override public void sessionDestroyed(HttpSessionEvent se) { System.out.println(&quot;销毁session了&quot;); } } 作用： ServletContextListener 利用它来，在servletcontext创建的时候， 1. 完成自己想要的初始化工作 2. 执行自定义任务调度。 执行某一个任务。 Timer HttpSessionListener 统计在线人数. 监听三个作用域属性状态变更 可以监听在作用域中值 添加 | 替换 | 移除的动作。 servletContext — ServletContextAttributeListener request — ServletRequestAttributeListener session — HttpSessionAttributeListener 监听httpSession里面存值的状态变更 这一类监听器不用注册。 HttpSessionBindingListener 监听对象与session 绑定和解除绑定 的动作 1. 让javaBean 实现该接口即可 @Override public void valueBound(HttpSessionBindingEvent event) { System.out.println(&quot;对象被绑定进来了&quot;); } @Override public void valueUnbound(HttpSessionBindingEvent event) { System.out.println(&quot;对象被解除绑定&quot;); } HttpSessionActivationListener 用于监听现在session的值 是 钝化 （序列化）还是活化 （反序列化）的动作 钝化 （序列化） 把内存中的数据 存储到硬盘上 活化 （反序列化） 把硬盘中的数据读取到内存中。 session的钝化活化的用意何在 session中的值可能会很多， 并且我们有很长一段时间不使用这个内存中的值， 那么可以考虑把session的值可以存储到硬盘上【钝化】，等下一次在使用的时候，在从硬盘上提取出来。 【活化】 如何让session的在一定时间内钝化. 做配置即可 1. 在tomcat里面 conf/context.xml 里面配置 对所有的运行在这个服务器的项目生效 2. 在conf/Catalina/localhost/context.xml 配置 对 localhost生效。 localhost:8080 3. 在自己的web工程项目中的 META-INF/context.xml 只对当前的工程生效。 maxIdleSwap ： 1分钟不用就钝化 directory ： 钝化后的那个文件存放的目录位置。 D:\tomcat\apache-tomcat-7.0.52\work\Catalina\localhost\ListenerDemo\domain &lt;Context&gt; &lt;Manager className=&quot;org.apache.catalina.session.PersistentManager&quot; maxIdleSwap=&quot;1&quot;&gt; &lt;Store className=&quot;org.apache.catalina.session.FileStore&quot; directory=&quot;domain&quot;/&gt; &lt;/Manager&gt; &lt;/Context&gt; Filter 过滤器 ， 其实就是对客户端发出来的请求进行过滤。 浏览器发出， 然后服务器派servlet处理。 在中间就可以过滤， 其实过滤器起到的是拦截的作用。 作用 对一些敏感词汇进行过滤 统一设置编码 自动登录 … 如何使用Filter 定义一个类， 实现Filter public class FilterDemo implements Filter { public void destroy() { } public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { System.out.println(&quot;来到过虑器了。。。&quot;); chain.doFilter(request, response); } public void init(FilterConfig fConfig) throws ServletException { } } 注册过滤器 在web.xml里面注册，注册的手法与servlet基本一样。 &lt;filter&gt; &lt;display-name&gt;FilterDemo&lt;/display-name&gt; &lt;filter-name&gt;FilterDemo&lt;/filter-name&gt; &lt;filter-class&gt;com.domain.filter.FilterDemo&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;FilterDemo&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; Filter的生命周期 创建 在服务器启动的时候就创建。 销毁 服务器停止的时候。 Filter执行顺序 客户端发出请求，先经过过滤器， 如果过滤器放行，那么才能到servlet 如果有多个过滤器， 那么他们会按照注册的映射顺序 来 排队。 只要有一个过滤器， 不放行，那么后面排队的过滤器以及咱们的servlet都不会收到请求。 Filter细节： init方法的参数 FilterConfig , 可以用于获取filter在注册的名字 以及初始化参数。 其实这里的设计的初衷与ServletConfig是一样的。 如果想放行，那么在doFilter 方法里面操作，使用参数 chain chain.doFilter(request, response); 放行， 让请求到达下一个目标。 /* 写法格式与servlet一样。 全路径匹配 以 / 开始 /LoginServlet 以目录匹配 以 / 开始 以 * 结束 /demo01/* 以后缀名匹配 以 * 开始 以后缀名结束 .jsp .html *.do 针对 dispatcher 设置 REQUEST ： 只要是请求过来，都拦截，默认就是REQUEST FORWARD : 只要是转发都拦截。 ERROR ： 页面出错发生跳转 INCLUDE ： 包含页面的时候就拦截。 自动登录 需求分析 1. 搭建环境 搭建数据库 搭建页面 登录servlet代码 protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { try { String userName = request.getParameter(&quot;username&quot;); String password = request.getParameter(&quot;password&quot;); String autoLogin = request.getParameter(&quot;auto_login&quot;); UserBean user = new UserBean(); user.setUsername(userName); user.setPassword(password); UserDao dao = new UserDaoImpl(); UserBean userBean = dao.login(user); if(userBean != null){ //成功了，进入首页 request.getSession().setAttribute(&quot;userBean&quot;, userBean); response.sendRedirect(&quot;index.jsp&quot;); }else{ //不成功... request.getRequestDispatcher(&quot;login.jsp&quot;).forward(request, response); } } catch (SQLException e) { e.printStackTrace(); } } 过滤器代码 过滤器的核心不是完成拦截不给 ， 还是放行显示。 它的核心是在放行之前，帮用户完成登录的功能。 实现思路 先判断session是否有效， 如果有效，就不用取cookie了，直接放行。 如果session失效了，那么就取 cookie。 没有cookie 放行 有cookie 1. 取出来cookie的值，然后完成登录 2. 把这个用户的值存储到session中 3. 放行。 /** * @see Filter#doFilter(ServletRequest, ServletResponse, FilterChain) */ public void doFilter(ServletRequest req, ServletResponse response, FilterChain chain) throws IOException, ServletException { try { HttpServletRequest request = (HttpServletRequest) req; //先判断，现在session中还有没有那个userBean. UserBean userBean = (UserBean) request.getSession().getAttribute(&quot;userBean&quot;); //还有，有效。 if(userBean != null){ chain.doFilter(request, response); }else{ //代表session失效了。 //2. 看cookie。 //1. 来请求的时候，先从请求里面取出cookie , 但是cookie有很多的key-value Cookie[] cookies = request.getCookies(); //2. 从一堆的cookie里面找出我们以前给浏览器发的那个cookie Cookie cookie = CookieUtil.findCookie(cookies, &quot;auto_login&quot;); //第一次来 if(cookie == null){ chain.doFilter(request, response); }else{ //不是第一次。 String value = cookie.getValue(); String username = value.split(&quot;#domain#&quot;)[0]; String password = value.split(&quot;#domain#&quot;)[1]; //完成登录 UserBean user = new UserBean(); user.setUsername(username); user.setPassword(password); UserDao dao = new UserDaoImpl(); userBean = dao.login(user); //使用session存这个值到域中，方便下一次未过期前还可以用。 request.getSession().setAttribute(&quot;userBean&quot;, userBean); chain.doFilter(request, response); } } } catch (Exception e) { e.printStackTrace(); chain.doFilter(req, response); } } BeanUtils的使用 BeanUtils.populate(bean, map); //注册自己的日期转换器 ConvertUtils.register(new MyDateConverter(), Date.class); ​ //转化数据 Map map = request.getParameterMap(); UserBean bean = new UserBean(); 转化map中的数据，放置到bean对象身上 BeanUtils.populate(bean, map); 总结Listener8个 三种类型 针对三个作用域的创建和销毁 针对三个作用域的值改变 【添加 | 替换 | 移除】 针对session中的值 【钝化 活化】 ， 【绑定 解绑】 钝化 ( 序列化 ) 内存中的对象存储到硬盘 超时失效。 session销毁了。 非正常关闭服务器， 钝化 。 正常关闭服务器 销毁 设置了session，多久时间。 context.xml 活化 (反序列化) 从硬盘里面读取到内存 ServletContextListner ： 应用被部署的时候， 服务器加载这个项目的时候，做一些初始化工作， 任务调度。HttpSessionListener ： 统计在线人数HttpSessionActivationListener ： 钝化活化处理 ​ ​ Filter 使用频率更高 如果要写一个过滤器。 定义一个类，实现接口 Filter 注册 . web.xml . 与servlet相似。 过滤器放行。 chain.doFilter(request, response); 过滤器生命周期 创建： 服务器加载这个项目的时候创建实例 销毁： 关闭服务器或者从服务器中移除项目的时候。]]></content>
      <categories>
        <category>Java开发</category>
      </categories>
      <tags>
        <tag>Listener</tag>
        <tag>Filter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax & Jquery]]></title>
    <url>%2F2019%2F02%2F14%2Fajax%2F</url>
    <content type="text"><![CDATA[Ajax &amp; Jquery Ajax &amp; JqueryAjax 是什么? “Asynchronous Javascript And XML”（异步JavaScript和XML）， 并不是新的技术，只是把原有的技术，整合到一起而已。 1.使用CSS和XHTML来表示。 2. 使用DOM模型来交互和动态显示。 3.使用XMLHttpRequest来和服务器进行异步通信。 4.使用javascript来绑定和调用。 有什么用? 咱们的网页如果想要刷新局部内容。 那么需要重新载入整个网页。用户体验不是很好。 就是为了解决局部刷新的问题。 保持其他部分不动，只刷新某些地方。 数据请求 Get1.创建对象 function ajaxFunction(){ var xmlHttp; try{ // Firefox, Opera 8.0+, Safari xmlHttp=new XMLHttpRequest(); } catch (e){ try{// Internet Explorer xmlHttp=new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;); } catch (e){ try{ xmlHttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); } catch (e){} } } return xmlHttp; } 2. 发送请求 //执行get请求 function get() { //1. 创建xmlhttprequest 对象 var request = ajaxFunction(); //2. 发送请求。 // http://localhost:8080/day16/demo01.jsp //http://localhost:8080/day16/DemoServlet01 /* 参数一： 请求类型 GET or POST 参数二： 请求的路径 参数三： 是否异步， true or false */ request.open(&quot;GET&quot; ,&quot;/day16/DemoServlet01&quot; ,true ); request.send(); } 如果发送请求的同时，还想获取数据，那么代码如下 //执行get请求 function get() { //1. 创建xmlhttprequest 对象 var request = ajaxFunction(); //2. 发送请求 request.open(&quot;GET&quot; ,&quot;/day16/DemoServlet01?name=aa&amp;age=18&quot; ,true ); //3. 获取响应数据 注册监听的意思。 一会准备的状态发生了改变，那么就执行 = 号右边的方法 request.onreadystatechange = function(){ //前半段表示 已经能够正常处理。 再判断状态码是否是200 if(request.readyState == 4 &amp;&amp; request.status == 200){ //弹出响应的信息 alert(request.responseText); } } request.send(); } 数据请求 Post​ //1. 创建对象 function ajaxFunction(){ var xmlHttp; try{ // Firefox, Opera 8.0+, Safari xmlHttp=new XMLHttpRequest(); } catch (e){ try{// Internet Explorer xmlHttp=new ActiveXObject("Msxml2.XMLHTTP"); } catch (e){ try{ xmlHttp=new ActiveXObject("Microsoft.XMLHTTP"); } catch (e){} } } return xmlHttp; } function post() { //1. 创建对象 var request = ajaxFunction(); //2. 发送请求 request.open( "POST", "/day16/DemoServlet01", true ); //如果不带数据，写这行就可以了 //request.send(); //如果想带数据，就写下面的两行 //如果使用的是post方式带数据，那么 这里要添加头， 说明提交的数据类型是一个经过url编码的form表单数据 request.setRequestHeader("Content-type","application/x-www-form-urlencoded"); //带数据过去 ， 在send方法里面写表单数据。 request.send("name=aobama&age=19"); } 需要获取数据 function post() { //1. 创建对象 var request = ajaxFunction(); //2. 发送请求 request.open( &quot;POST&quot;, &quot;/day16/DemoServlet01&quot;, true ); //想获取服务器传送过来的数据， 加一个状态的监听。 request.onreadystatechange=function(){ if(request.readyState==4 &amp;&amp; request.status == 200){ alert(&quot;post：&quot;+request.responseText); } } //如果使用的是post方式带数据，那么 这里要添加头， 说明提交的数据类型是一个经过url编码的form表单数据 request.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;); //带数据过去 ， 在send方法里面写表单数据。 request.send(&quot;name=aobama&amp;age=19&quot;); } 校验用户名是否可用1. 搭建环境 页面准备 &lt;body&gt; &lt;table border=&quot;1&quot; width=&quot;500&quot;&gt; &lt;tr&gt; &lt;td&gt;用户名:&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot; onblur=&quot;checkUserName()&quot;&gt;&lt;span id=&quot;span01&quot;&gt;&lt;/span&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;邮箱&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;简介&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;注册&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 数据库准备 2. Servlet代码 protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { try { request.setCharacterEncoding(&quot;UTF-8&quot;); //1. 检测是否存在 String name = request.getParameter(&quot;name&quot;); System.out.println(&quot;name=&quot;+name); UserDao dao = new UserDaomImpl(); boolean isExist = dao.checkUserName(name); //2. 通知页面，到底有还是没有。 if(isExist){ response.getWriter().println(1); //存在用户名 }else{ response.getWriter().println(2); //不存在该用户名 } } catch (SQLException e) { e.printStackTrace(); } } 3. Dao代码public class UserDaomImpl implements UserDao{ @Override public boolean checkUserName(String username) throws SQLException { QueryRunner runner = new QueryRunner(JDBCUtil02.getDataSource()); String sql = &quot;select count(*) from t_user where username =?&quot;; runner.query(sql, new ScalarHandler(), username); Long result = (Long) runner.query(sql, new ScalarHandler(), username); return result &gt; 0 ; } } jsp页面显示​​ function checkUserName() { //获取输入框的值 document 整个网页 var name = document.getElementById(&quot;name&quot;).value; // value value() val val() //1. 创建对象 var request = ajaxFunction(); //2. 发送请求 request.open(&quot;POST&quot; ,&quot;/day16/CheckUserNameServlet&quot; , true ); //注册状态改变监听，获取服务器传送过来的数据 request.onreadystatechange = function(){ if(request.readyState == 4 &amp;&amp; request.status == 200){ //alert(request.responseText); var data = request.responseText; if(data == 1){ //alert(&quot;用户名已存在&quot;); document.getElementById(&quot;span01&quot;).innerHTML = &quot;&lt;font color=&apos;red&apos;&gt;用户名已存在!&lt;/font&gt;&quot;; }else{ document.getElementById(&quot;span01&quot;).innerHTML = &quot;&lt;font color=&apos;green&apos;&gt;用户名可用!&lt;/font&gt;&quot;; //alert(&quot;用户名未存在&quot;); } } } request.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;); request.send(&quot;name=&quot;+name); } JQuery 是什么? javascript 的代码框架。 有什么用? 简化代码，提高效率。 核心 write less do more , 写得更少，做的更多。 load&lt;a href=&quot;&quot; onclick=&quot;load()&quot;&gt;使用JQuery执行load方法&lt;/a&gt; 有两次刷新， 先走 onClick的方法，取到数据回来之后，赋值显示。 接着 走 href=&quot;&quot;的路径，但是这个属性没有给值，所以会把当前的页面重新再刷新一次。所以导致看不见值。 //找到这个元素， 去执行加载的动作， 加载/day16/DemoServlet02 ， 得到的数据，赋值显示 $(&quot;#aaa&quot;).load(&quot;/day16/DemoServlet02&quot; , function(responseText , statusTXT , xhr) { //找到id为text01的元素， 设置它的value属性值为 responseText 对应的值 $(&quot;#aaa&quot;).val(responseText); }); Get$.get(&quot;/day16/DemoServlet02&quot; , function(data ,status) { $(&quot;#div01&quot;).text(data); }); 赋值显示 val(“aa”); 只能放那些标签带有value属性 html(“aa”); —写html代码 text(“aa”); 其实没有什么区别，如果想针对这分数据做html样式处理，那么只能用html() load &amp; get load $(&quot;#元素id&quot;).load(url地址); $(&quot;#div1&quot;).load(serlvet); ---&gt; 使用的get请求，回来赋值的时候， 使用text（）;去赋值 get 语法格式 ： $.get(URL,callback); 使用案例： $.get(&quot;/day16/DemoServlet02&quot; , function(data ,status) { $(&quot;#div01&quot;).text(data); }); post 语法格式：$.post(URL,data,callback); function post() { $.post(&quot;/day16/DemoServlet02&quot;, {name:&quot;zhangsan&quot;,age:18},function(data,status) { //想要放数据到div里面去。 --- 找到div $(&quot;#div01&quot;).html(data); }); } 使用JQuery去实现校验用户名function checkUserName() { //1. 获取输入框的内容 var name = $(&quot;#name&quot;).val(); //2. 发送请求 $.post(&quot;/day16/CheckUserNameServlet&quot; , {name:name} , function(data , status){ //alert(data); if(data == 1){//用户名存在 //alert(&quot;用户名存在&quot;); $(&quot;#span01&quot;).html(&quot;&lt;font color=&apos;red&apos;&gt;用户名已被注册&lt;/font&gt;&quot;); }else{ //alert(&quot;用户名可用&quot;); $(&quot;#span01&quot;).html(&quot;&lt;font color=&apos;green&apos;&gt;用户名可以使用&lt;/font&gt;&quot;); } } ); //3. 输出响应的数据到页面上。 } 实现百度搜索提示搭建环境 定义首页 &lt;body&gt; &lt;center&gt; &lt;h2&gt;黑马&lt;/h2&gt; &lt;input type=&quot;text&quot; name=&quot;word&quot; id=&quot;word&quot; style=&quot;width: 600px ; height: 50px ;font-size: 20px;&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;黑马一下&quot; style=&quot;height: 55px ; width: 100px ; &quot;&gt; &lt;div id=&quot;div01&quot; style=&quot;position:relative; left : -54px; width: 600px; height: 200px ; border: 1px solid blue; display: none&quot;&gt;&lt;/div&gt; &lt;/center&gt; &lt;/body&gt; 定义数据库 捕获键盘弹起$(function(){ $(“#word”).keyup(function() { alert(“键盘弹起了..”); })}); JS请求$(function(){ $(&quot;#word&quot;).keyup(function() { //2。 获取输入框的值 //var word = $(&quot;#word&quot;).val(); //this 对应就是执行这个方法的那个对象， $(&quot;#word&quot;) var word = $(this).val(); if(word == &quot;&quot;){ $(&quot;#div01&quot;).hide(); }else{ //3. 请求数据。 $.post(&quot;find&quot;,{word:word} ,function(data , status){ //alert(data); $(&quot;#div01&quot;).show(); $(&quot;#div01&quot;).html(data); }); } }) }); Servlet代码 protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { request.setCharacterEncoding(&quot;utf-8&quot;); try { //1. 先获取参数 String word = request.getParameter(&quot;word&quot;); System.out.println(&quot;word=&quot;+word); //2. 让dao执行查询 WordsDao dao = new WordsDaoImpl(); List&lt;WordBean&gt; list = dao.findWords(word); for (WordBean wordBean : list) { System.out.println(&quot;===&quot;+wordBean.toString()); } request.setAttribute(&quot;list&quot;, list); //3. 返回数据 response.setContentType(&quot;text/html;charset=utf-8&quot;); //response.getWriter().write(&quot;数据是：&quot;); request.getRequestDispatcher(&quot;list.jsp&quot;).forward(request, response); } catch (SQLException e) { e.printStackTrace(); } } list.jsp&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&gt; ​​ ​ &lt;c:forEach items=”${list }” var=”wordBean”&gt;​ ​ ${wordBean.words}​ ​ &lt;/c:forEach&gt;​ 使用JQuery实现 省市联动环境准备 准备数据库 2 。 准备页面 &lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-1.11.3.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/city.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; 省份: &lt;select name=&quot;province&quot; id =&quot;province&quot;&gt; &lt;option value=&quot;&quot; &gt;-请选择 - &lt;option value=&quot;1&quot; &gt;广东 &lt;option value=&quot;2&quot; &gt;湖南 &lt;option value=&quot;3&quot; &gt;湖北 &lt;option value=&quot;4&quot; &gt;四川 &lt;/select&gt; 城市: &lt;select name=&quot;city&quot; id=&quot;city&quot;&gt; &lt;option value=&quot;&quot; &gt;-请选择 - &lt;/select&gt; &lt;/body&gt; XStream的使用//3. 返回数据。手动拼 ---&gt; XStream 转化 bean对象成 xml XStream xStream = new XStream(); //想把id做成属性 xStream.useAttributeFor(CityBean.class, &quot;id&quot;); //设置别名 xStream.alias(&quot;city&quot;, CityBean.class); //转化一个对象成xml字符串 String xml = xStream.toXML(list); JS代码 $(function() { //1。找到省份的元素 $(&quot;#province&quot;).change(function() { //2. 一旦里面的值发生了改变，那么就去请求该省份的城市数据 //$(&quot;#province&quot;).varl(); var pid = $(this).val(); /*&lt;list&gt; &lt;city&gt; &lt;id&gt;1&lt;id&gt; &lt;pid&gt;1&lt;/pid&gt; &lt;cname&gt;深圳&lt;/cname&gt; &lt;/city&gt; &lt;city &gt; &lt;id&gt;2&lt;id&gt; &lt;pid&gt;1&lt;/pid&gt; &lt;cname&gt;东莞&lt;/cname&gt; &lt;/city&gt; &lt;/list&gt;*/ $.post( &quot;CityServlet&quot;,{pid:pid} ,function(data,status){ //alert(&quot;回来数据了:&quot;+data); //先清空以前的值： $(&quot;#city&quot;).html(&quot;&lt;option value=&apos;&apos; &gt;-请选择-&quot;) //遍历： //从data数据里面找出所有的city ， 然后遍历所有的city。 //遍历一个city，就执行一次function方法 $(data).find(&quot;city&quot;).each(function() { //遍历出来的每一个city，取它的孩子。 id , cname var id = $(this).children(&quot;id&quot;).text(); var cname = $(this).children(&quot;cname&quot;).text(); $(&quot;#city&quot;).append(&quot;&lt;option value=&apos;&quot;+id+&quot;&apos; &gt;&quot;+cname) }); } ); }); }); 服务器和客户端数据传输的方式 xml &lt;list&gt; &lt;city&gt; &lt;id&gt;1&lt;id&gt; &lt;pid&gt;1&lt;/pid&gt; &lt;cname&gt;深圳&lt;/cname&gt; &lt;/city&gt; &lt;city &gt; &lt;id&gt;2&lt;id&gt; &lt;pid&gt;1&lt;/pid&gt; &lt;cname&gt;东莞&lt;/cname&gt; &lt;/city&gt; &lt;/list&gt; json 阅读性更好 、 容量更小。 {“name”:”aaa” , “age”:19} 把javaBean 转化成 json数据 //3. 把list ---&gt; json数据 //JSONArray ---&gt; 变成数组 ， 集合 [] //JSONObject ---&gt; 变成简单的数据 { name : zhangsan , age:18} JSONArray jsonArray = JSONArray.fromObject(list); String json = jsonArray.toString(); 使用json格式数据显示省市联动效果​ serlvet代码： protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { try { //1. 获取参数 int pid = Integer.parseInt(request.getParameter(&quot;pid&quot;)); //2 找出所有的城市 CityDao dao = new CityDaoImpl(); List&lt;CityBean&gt; list = dao.findCity(pid); //3. 把list ---&gt; json数据 //JSONArray ---&gt; 变成数组 ， 集合 [] //JSONObject ---&gt; 变成简单的数据 { name : zhangsan , age:18} JSONArray jsonArray = JSONArray.fromObject(list); String json = jsonArray.toString(); response.setContentType(&quot;text/html;charset=utf-8&quot;); response.getWriter().write(json); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); }; } js代码 $(function() { //1。找到省份的元素 $(&quot;#province&quot;).change(function() { //2. 一旦里面的值发生了改变，那么就去请求该省份的城市数据 //$(&quot;#province&quot;).varl(); var pid = $(this).val(); /*[ { &quot;cname&quot;: &quot;深圳&quot;, &quot;id&quot;: 1, &quot;pid&quot;: 1 }, { &quot;cname&quot;: &quot;东莞&quot;, &quot;id&quot;: 2, &quot;pid&quot;: 1 } ... ]*/ $.post( &quot;CityServlet02&quot;,{pid:pid} ,function(data,status){ //先清空 $(&quot;#city&quot;).html(&quot;&lt;option value=&apos;&apos; &gt;-请选择-&quot;); //再遍历，追加 $(data).each(function(index , c) { $(&quot;#city&quot;).append(&quot;&lt;option value=&apos;&quot;+c.id+&quot;&apos; &gt;&quot;+c.cname) }); },&quot;json&quot; ); }); }); 总结Ajax发送get请求 发送post请求 都要求带数据 + 获取数据＋ 放置到元素上。 JQuery发送get请求 发送post请求 都要求带数据 + 获取数据＋ 放置到元素上。 --------------------------------------- 1. 服务器返回xml数据 2. 服务器返回json数据]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>Ajax</tag>
        <tag>Jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MVC]]></title>
    <url>%2F2019%2F02%2F13%2Fmvc%2F</url>
    <content type="text"><![CDATA[MVC 元数据 Meata data 描述数据的数据 String sql , 描述这份sql字符串的数据叫做元数据 数据库元数据 DatabaseMetaData参数元数据 ParameterMetaData结果集元数据 ResultSetMetaData MVC设计模式JSP的开发模式 三层架构&amp;MVC练习 学生信息管理系统数据库准备CREATE DATABASE stus; USE stus; CREATE TABLE stu ( sid INT PRIMARY KEY AUTO_INCREMENT, sname VARCHAR (20), gender VARCHAR (5), phone VARCHAR (20), birthday DATE, hobby VARCHAR(50), info VARCHAR(200) ); 查询 先写一个JSP 页面， 里面放一个超链接 。 学生列表显示 写Servlet， 接收请求， 去调用 Service , 由service去调用dao 先写Dao , 做Dao实现。 public interface StudentDao { ​​ /** 查询所有学生 @return List */List findAll() throws SQLException ;} public class StudentDaoImpl implements StudentDao { ​​ /*​ 查询所有学生​ @throws SQLException​ /​ @Override​ public List findAll() throws SQLException {​ QueryRunner runner = new QueryRunner(JDBCUtil02.getDataSource());​ return runner.query(“select * from stu”, new BeanListHandler(Student.class));​ }​​ } 再Service , 做Service的实现。 /** * 这是学生的业务处理规范 * @author xiaomi * */ public interface StudentService { /** * 查询所有学生 * @return List&lt;Student&gt; */ List&lt;Student&gt; findAll() throws SQLException ; } ------------------------------------------ /** * 这是学生业务实现 * @author xiaomi * */ public class StudentServiceImpl implements StudentService{ @Override public List&lt;Student&gt; findAll() throws SQLException { StudentDao dao = new StudentDaoImpl(); return dao.findAll(); } } 在servlet 存储数据，并且做出页面响应。 protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { ​​ try {​ //1. 查询出来所有的学生​ StudentService service = new StudentServiceImpl();​ List list = service.findAll();​​ //2. 先把数据存储到作用域中​ request.setAttribute(“list”, list);​ //3. 跳转页面​ request.getRequestDispatcher(“list.jsp”).forward(request, response);​ } catch (SQLException e) { e.printStackTrace(); } } 在list.jsp上显示数据 EL + JSTL + 表格 增加 先跳转到增加的页面 ， 编写增加的页面 点击添加，提交数据到AddServlet . 处理数据。 调用service 调用dao, 完成数据持久化。 完成了这些存储工作后，需要跳转到列表页面。 这里不能直接跳转到列表页面，否则没有什么内容显示。 应该先跳转到查询所有学生信息的那个Servlet， 由那个Servlet再去跳转到列表页面。 爱好的value 值有多个。 request.getParameter(“hobby”);String[] hobby = request.getParameterValues(“hobby”) —&gt; String[]String value = Arrays.toString(hobby): // [爱好， 篮球， 足球] 删除 点击超链接，弹出一个询问是否删除的对话框，如果点击了确定，那么就真的删除。 &lt;a href=&quot;#&quot; onclick=&quot;doDelete(${stu.sid})&quot;&gt;删除&lt;/a&gt; ​ 让超链接，执行一个js方法 &lt;script type=&quot;text/javascript&quot;&gt; function doDelete(sid) { /* 如果这里弹出的对话框，用户点击的是确定，就马上去请求Servlet。 如何知道用户点击的是确定。 如何在js的方法中请求servlet。 */ var flag = confirm(&quot;是否确定删除?&quot;); if(flag){ //表明点了确定。 访问servlet。 在当前标签页上打开 超链接， //window.location.href=&quot;DeleteServlet?sid=&quot;+sid; location.href=&quot;DeleteServlet?sid=&quot;+sid; } } &lt;/script&gt; 在js访问里面判断点击的选项，然后跳转到servlet。 servlet收到了请求，然后去调用service ， service去调用dao 更新 点击列表上的更新， 先跳转到一个EditServlet 在这个Servlet里面，先根据ID 去查询这个学生的所有信息出来。 跳转到更新的页面。 ，然后在页面上显示数据 &lt;tr&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;sname&quot; value=&quot;${stu.sname }&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;性别&lt;/td&gt; &lt;td&gt; &lt;!-- 如果性别是男的， 可以在男的性别 input标签里面， 出现checked , 如果性别是男的， 可以在女的性别 input标签里面，出现checked --&gt; &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;男&quot; &lt;c:if test=&quot;${stu.gender == &apos;男&apos;}&quot;&gt;checked&lt;/c:if&gt;&gt;男 &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;女&quot; &lt;c:if test=&quot;${stu.gender == &apos;女&apos;}&quot;&gt;checked&lt;/c:if&gt;&gt;女 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;爱好&lt;/td&gt; &lt;td&gt; &lt;!-- 爱好： 篮球 ， 足球 ， 看书 因为爱好有很多个， 里面存在包含的关系 --&gt; &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;游泳&quot; &lt;c:if test=&quot;${fn:contains(stu.hobby,&apos;游泳&apos;) }&quot;&gt;checked&lt;/c:if&gt;&gt;游泳 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;篮球&quot; &lt;c:if test=&quot;${fn:contains(stu.hobby,&apos;篮球&apos;) }&quot;&gt;checked&lt;/c:if&gt;&gt;篮球 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;足球&quot; &lt;c:if test=&quot;${fn:contains(stu.hobby,&apos;足球&apos;) }&quot;&gt;checked&lt;/c:if&gt;&gt;足球 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;看书&quot; &lt;c:if test=&quot;${fn:contains(stu.hobby,&apos;看书&apos;) }&quot;&gt;checked&lt;/c:if&gt;&gt;看书 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;写字&quot; &lt;c:if test=&quot;${fn:contains(stu.hobby,&apos;写字&apos;) }&quot;&gt;checked&lt;/c:if&gt;&gt;写字 &lt;/td&gt; &lt;/tr&gt; 修改完毕后，提交数据到UpdateServlet 提交上来的数据是没有带id的，所以我们要手动创建一个隐藏的输入框， 在这里面给定id的值， 以便提交表单，带上id。 &lt;form method=&quot;post&quot; action=&quot;UpdateServlet&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;sid&quot; value=&quot;${stu.sid }&quot;&gt; ... &lt;/form&gt; 获取数据，调用service， 调用dao. 分页功能 物理分页 （真分页） 来数据库查询的时候，只查一页的数据就返回了。 优点 内存中的数据量不会太大 缺点：对数据库的访问频繁了一点。 SELECT * FROM stu LIMIT 5 OFFSET 2 逻辑分页 （假分页） 一口气把所有的数据全部查询出来，然后放置在内存中。 优点： 访问速度快。 缺点： 数据库量过大，内存溢出。 ​]]></content>
      <categories>
        <category>Java开发</category>
      </categories>
      <tags>
        <tag>MVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事务 & 数据库连接池 & DBUtils]]></title>
    <url>%2F2019%2F02%2F11%2Fdbutils%2F</url>
    <content type="text"><![CDATA[事务 &amp; 数据库连接池 &amp; DBUtils 事务&amp;数据库连接池&amp;DBUtils事务 Transaction 其实指的一组操作，里面包含许多个单一的逻辑。只要有一个逻辑没有执行成功，那么都算失败。 所有的数据都回归到最初的状态(回滚) 为什么要有事务? 为了确保逻辑的成功。 例子： 银行的转账。 使用命令行方式演示事务。 开启事务 start transaction; 提交或者回滚事务 commit; 提交事务， 数据将会写到磁盘上的数据库 rollback ; 数据回滚，回到最初的状态。 关闭自动提交功能。 演示事务 使用代码方式演示事务 代码里面的事务，主要是针对连接来的。 通过conn.setAutoCommit（false ）来关闭自动提交的设置。 提交事务 conn.commit(); 回滚事务 conn.rollback(); @Test public void testTransaction(){ Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try { conn = JDBCUtil.getConn(); //连接，事务默认就是自动提交的。 关闭自动提交。 conn.setAutoCommit(false); String sql = &quot;update account set money = money - ? where id = ?&quot;; ps = conn.prepareStatement(sql); //扣钱， 扣ID为1 的100块钱 ps.setInt(1, 100); ps.setInt(2, 1); ps.executeUpdate(); ​ int a = 10 /0 ; //加钱， 给ID为2 加100块钱 ps.setInt(1, -100); ps.setInt(2, 2); ps.executeUpdate(); //成功： 提交事务。 conn.commit(); } catch (SQLException e) { try { //事变： 回滚事务 conn.rollback(); } catch (SQLException e1) { e1.printStackTrace(); } e.printStackTrace(); }finally { JDBCUtil.release(conn, ps, rs); } } 事务的特性 原子性 指的是 事务中包含的逻辑，不可分割。 一致性 指的是 事务执行前后。数据完整性 隔离性 指的是 事务在执行期间不应该受到其他事务的影响 持久性 指的是 事务执行成功，那么数据应该持久保存到磁盘上。 事务的安全隐患 不考虑隔离级别设置，那么会出现以下问题。 读 脏读 不可重读读 幻读. * 脏读 &gt; 一个事务读到另外一个事务还未提交的数据 * 不可重复读 &gt; 一个事务读到了另外一个事务提交的数据 ，造成了前后两次查询结果不一致。 读未提交 演示 设置A窗口的隔离级别为 读未提交 两个窗口都分别开启事务 写 丢失更新 读已提交演示 设置A窗口的隔离级别为 读已提交 A B 两个窗口都开启事务， 在B窗口执行更新操作。 在A窗口执行的查询结果不一致。 一次是在B窗口提交事务之前，一次是在B窗口提交事务之后。 这个隔离级别能够屏蔽 脏读的现象， 但是引发了另一个问题 ，不可重复读。 可串行化 如果有一个连接的隔离级别设置为了串行化 ，那么谁先打开了事务， 谁就有了先执行的权利， 谁后打开事务，谁就只能得着，等前面的那个事务，提交或者回滚后，才能执行。 但是这种隔离级别一般比较少用。 容易造成性能上的问题。 效率比较低。 按效率划分，从高到低 读未提交 &gt; 读已提交 &gt; 可重复读 &gt; 可串行化 按拦截程度 ，从高到底 可串行化 &gt; 可重复读 &gt; 读已提交 &gt; 读未提交 事务总结需要掌握的 在代码里面会使用事务 conn.setAutoCommit(false); conn.commit(); conn.rollback(); 事务只是针对连接连接对象，如果再开一个连接对象，那么那是默认的提交。 事务是会自动提交的。 需要了解的安全隐患读 脏读 一个事务读到了另一个事务未提交的数据 不可重复读 一个事务读到了另一个事务已提交的数据，造成前后两次查询结果不一致 幻读 一个事务读到了另一个事务insert的数据 ，造成前后查询结果不一致 。 写 丢失更新。 隔离级别读未提交 引发问题： 脏读 读已提交 解决： 脏读 ， 引发： 不可重复读 可重复读 解决： 脏读 、 不可重复读 ， 未解决： 幻读 可串行化 解决： 脏读、 不可重复读 、 幻读。 mySql 默认的隔离级别是 可重复读 Oracle 默认的隔离级别是 读已提交 丢失更新 解决丢失更新 悲观锁 可以在查询的时候，加入 for update 乐观锁 要求程序员自己控制。 数据库连接池 数据库的连接对象创建工作，比较消耗性能。 2.一开始现在内存中开辟一块空间（集合） ， 一开先往池子里面放置 多个连接对象。 后面需要连接的话，直接从池子里面去。不要去自己创建连接了。 使用完毕， 要记得归还连接。确保连接对象能循环利用。 自定义数据库连接池 代码实现 出现的问题： 需要额外记住 addBack方法 单例。 无法面向接口编程。 UserDao dao = new UserDaoImpl();dao.insert(); DataSource dataSource = new MyDataSource(); 因为接口里面没有定义addBack方法。 4. 怎么解决? 以addBack 为切入点。 解决自定义数据库连接池出现的问题。 由于多了一个addBack 方法，所以使用这个连接池的地方，需要额外记住这个方法，并且还不能面向接口编程。 我们打算修改接口中的那个close方法。 原来的Connection对象的close方法，是真的关闭连接。打算修改这个close方法，以后在调用close， 并不是真的关闭，而是归还连接对象。 如何扩展某一个方法? 原有的方法逻辑，不是我们想要的。 想修改自己的逻辑 直接改源码 无法实现。 继承， 必须得知道这个接口的具体实现是谁。 使用装饰者模式。 开源连接池DBCP 导入jar文件 不使用配置文件： public void testDBCP01(){ ​ Connection conn = null; PreparedStatement ps = null; try { //1. 构建数据源对象 BasicDataSource dataSource = new BasicDataSource(); //连的是什么类型的数据库， 访问的是哪个数据库 ， 用户名， 密码。。 //jdbc:mysql://localhost/bank 主协议：子协议 ://本地/数据库 dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); dataSource.setUrl(&quot;jdbc:mysql://localhost/bank&quot;); dataSource.setUsername(&quot;root&quot;); dataSource.setPassword(&quot;root&quot;); ​ //2. 得到连接对象 conn = dataSource.getConnection(); String sql = “insert into account values(null , ? , ?)”; ps = conn.prepareStatement(sql); ps.setString(1, “admin”); ps.setInt(2, 1000); ps.executeUpdate(); } catch (SQLException e) { e.printStackTrace(); }finally { JDBCUtil.release(conn, ps); } } 使用配置文件方式： Connection conn = null; PreparedStatement ps = null; try { BasicDataSourceFactory factory = new BasicDataSourceFactory(); Properties properties = new Properties(); InputStream is = new FileInputStream(&quot;src//dbcpconfig.properties&quot;); properties.load(is); DataSource dataSource = factory.createDataSource(properties); //2. 得到连接对象 conn = dataSource.getConnection(); String sql = &quot;insert into account values(null , ? , ?)&quot;; ps = conn.prepareStatement(sql); ps.setString(1, &quot;liangchaowei&quot;); ps.setInt(2, 100); ps.executeUpdate(); } catch (Exception e) { e.printStackTrace(); }finally { JDBCUtil.release(conn, ps); } ​ C3P0 拷贝jar文件 到 lib目录 不使用配置文件方式Connection conn = null; PreparedStatement ps = null; try { //1. 创建datasource ComboPooledDataSource dataSource = new ComboPooledDataSource(); //2. 设置连接数据的信息 dataSource.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;); //忘记了---&gt; 去以前的代码 ---&gt; jdbc的文档 dataSource.setJdbcUrl(&quot;jdbc:mysql://localhost/bank&quot;); dataSource.setUser(&quot;root&quot;); dataSource.setPassword(&quot;root&quot;); //2. 得到连接对象 conn = dataSource.getConnection(); String sql = &quot;insert into account values(null , ? , ?)&quot;; ps = conn.prepareStatement(sql); ps.setString(1, &quot;admi234n&quot;); ps.setInt(2, 103200); ps.executeUpdate(); } catch (Exception e) { e.printStackTrace(); }finally { JDBCUtil.release(conn, ps); } 使用配置文件方式//默认会找 xml 中的 default-config 分支。 ComboPooledDataSource dataSource = new ComboPooledDataSource(); //2. 设置连接数据的信息 dataSource.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;); //忘记了---&gt; 去以前的代码 ---&gt; jdbc的文档 dataSource.setJdbcUrl(&quot;jdbc:mysql://localhost/bank&quot;); dataSource.setUser(&quot;root&quot;); dataSource.setPassword(&quot;root&quot;); //2. 得到连接对象 conn = dataSource.getConnection(); String sql = &quot;insert into account values(null , ? , ?)&quot;; ps = conn.prepareStatement(sql); ps.setString(1, &quot;admi234n&quot;); ps.setInt(2, 103200); DBUtils增删改 //dbutils 只是帮我们简化了CRUD 的代码， 但是连接的创建以及获取工作。 不在他的考虑范围 QueryRunner queryRunner = new QueryRunner(new ComboPooledDataSource()); ​ //增加 //queryRunner.update(“insert into account values (null , ? , ? )”, “aa” ,1000); //删除 //queryRunner.update(&quot;delete from account where id = ?&quot;, 5); //更新 //queryRunner.update(&quot;update account set money = ? where id = ?&quot;, 10000000 , 6); 查询 直接new接口的匿名实现类 QueryRunner queryRunner = new QueryRunner(new ComboPooledDataSource()); Account account = queryRunner.query(&quot;select * from account where id = ?&quot;, new ResultSetHandler&lt;Account&gt;(){ @Override public Account handle(ResultSet rs) throws SQLException { Account account = new Account(); while(rs.next()){ String name = rs.getString(&quot;name&quot;); int money = rs.getInt(&quot;money&quot;); account.setName(name); account.setMoney(money); } return account; } }, 6); System.out.println(account.toString()); 直接使用框架已经写好的实现类。 * 查询单个对象 QueryRunner queryRunner = new QueryRunner(new ComboPooledDataSource()); //查询单个对象 Account account = queryRunner.query(&quot;select * from account where id = ?&quot;, new BeanHandler&lt;Account&gt;(Account.class), 8); ​ * 查询多个对象 QueryRunner queryRunner = new QueryRunner(new ComboPooledDataSource()); List&lt;Account&gt; list = queryRunner.query(&quot;select * from account &quot;, new BeanListHandler&lt;Account&gt;(Account.class)); ResultSetHandler 常用的实现类以下两个是使用频率最高的 BeanHandler, 查询到的单个数据封装成一个对象 BeanListHandler, 查询到的多个数据封装 成一个List&lt;对象&gt; ArrayHandler, 查询到的单个数据封装成一个数组 ArrayListHandler, 查询到的多个数据封装成一个集合 ，集合里面的元素是数组。 ​​ MapHandler, 查询到的单个数据封装成一个map MapListHandler,查询到的多个数据封装成一个集合 ，集合里面的元素是map。 ColumnListHandlerKeyedHandlerScalarHandler 总结事务使用命令行演示 使用代码演示 脏读、 不可重复读、 幻读丢失更新 悲观锁 乐观锁 4个隔离级别 读未提交 读已提交 可重复读 可串行化 数据连接池 DBCP 不使用配置 使用配置 C3P0 不使用配置 使用配置 （必须掌握） 自定义连接池 装饰者模式 DBUtils 简化了我们的CRUD ， 里面定义了通用的CRUD方法。 queryRunner.update(); queryRunner.query]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSP & EL & JSTL]]></title>
    <url>%2F2019%2F02%2F10%2Fjspandelandjstl%2F</url>
    <content type="text"><![CDATA[JSP &amp; EL &amp; JSTL JSP &amp; EL &amp; JSTLjsp Java Server Page 什么是jsp 从用户角度看待 ，就是是一个网页 ， 从程序员角度看待 ， 其实是一个java类， 它继承了servlet，所以可以直接说jsp 就是一个Servlet. 为什么会有jsp? html 多数情况下用来显示静态内容 ， 一成不变的。 但是有时候我们需要在网页上显示一些动态数据， 比如： 查询所有的学生信息， 根据姓名去查询具体某个学生。 这些动作都需要去查询数据库，然后在网页上显示。 html是不支持写java代码 ， jsp里面可以写java代码。 怎么用JSP指令写法&lt;%@ 指令名字 %&gt; page指令 language 表明jsp页面中可以写java代码 contentType 其实即使说这个文件是什么类型，告诉浏览器我是什么内容类型，以及使用什么编码 contentType=&quot;text/html; charset=UTF-8&quot; text/html MIMEType 这是一个文本，html网页 pageEncoding jsp内容编码 extends 用于指定jsp翻译成java文件后，继承的父类是谁，一般不用改。 import 导包使用的，一般不用手写。 session 值可选的有true or false . 用于控制在这个jsp页面里面，能够直接使用session对象。 具体的区别是，请看翻译后的java文件 如果该值是true , 那么在代码里面会有getSession（）的调用，如果是false : 那么就不会有该方法调用，也就是没有session对象了。在页面上自然也就不能使用session了。 errorPage 指的是错误的页面， 值需要给错误的页面路径 isErrorPage 上面的errorPage 用于指定错误的时候跑到哪一个页面去。 那么这个isErroPage , 就是声明某一个页面到底是不是错误的页面。 include 包含另外一个jsp的内容进来。 &lt;%@ include file=&quot;other02.jsp&quot;%&gt; 背后细节: 把另外一个页面的所有内容拿过来一起输出。 所有的标签元素都包含进来。 taglib &lt;%@ taglib prefix=&quot;&quot; uri=&quot;&quot;%&gt; uri: 标签库路径 prefix : 标签库的别名 JSP 动作标签&lt;jsp:include page=&quot;&quot;&gt;&lt;/jsp:include&gt; &lt;jsp:param value=&quot;&quot; name=&quot;&quot;/&gt; &lt;jsp:forward page=&quot;&quot;&gt;&lt;/jsp:forward&gt; jsp:include &lt;jsp:include page=”other02.jsp”&gt;&lt;/jsp:include&gt; 包含指定的页面， 这里是动态包含。 也就是不把包含的页面所有元素标签全部拿过来输出，而是把它的运行结果拿过来。 jsp:forward &lt;jsp:forward page=&quot;&quot;&gt;&lt;/jsp:forward&gt; 前往哪一个页面。 &lt;% //请求转发 request.getRequestDispatcher(&quot;other02.jsp&quot;).forward(request, response); %&gt; jsp:param 意思是： 在包含某个页面的时候，或者在跳转某个页面的时候，加入这个参数。 ​​ &lt;jsp:forward page=”other02.jsp”&gt;​ &lt;jsp:param value=”beijing” name=”address”/&gt;​ &lt;/jsp:forward&gt;​​ 在other02.jsp中获取参数 &lt;br&gt;收到的参数是：&lt;br&gt; &lt;%= request.getParameter(&quot;address&quot;)%&gt; JSP内置对象 所谓内置对象，就是我们可以直接在jsp页面中使用这些对象。 不用创建。 pageContext request session application 以上4个是作用域对象 , 作用域 表示这些对象可以存值，他们的取值范围有限定。 setAttribute 和 getAttribute 使用作用域来存储数据&lt;br&gt; &lt;% pageContext.setAttribute(&quot;name&quot;, &quot;page&quot;); request.setAttribute(&quot;name&quot;, &quot;request&quot;); session.setAttribute(&quot;name&quot;, &quot;session&quot;); application.setAttribute(&quot;name&quot;, &quot;application&quot;); %&gt; 取出四个作用域中的值&lt;br&gt; &lt;%=pageContext.getAttribute(&quot;name&quot;)%&gt; &lt;%=request.getAttribute(&quot;name&quot;)%&gt; &lt;%=session.getAttribute(&quot;name&quot;)%&gt; &lt;%=application.getAttribute(&quot;name&quot;)%&gt; 作用域范围大小： pageContext -- request --- session -- application 四个作用域的区别 pageContext 【PageContext】 作用域仅限于当前的页面。 还可以获取到其他八个内置对象。 request 【HttpServletRequest】 作用域仅限于一次请求， 只要服务器对该请求做出了响应。 这个域中存的值就没有了。 session 【HttpSession】 作用域限于一次会话（多次请求与响应） 当中。 application 【ServletContext】 整个工程都可以访问， 服务器关闭后就不能访问了。 out 【JspWriter】 response 【HttpServletResponse】 exception 【Throwable】 page 【Object】 —就是这个jsp翻译成的java类的实例对象 config 【ServletConfig】 EL表达式 是为了简化咱们的jsp代码，具体一点就是为了简化在jsp里面写的那些java代码。 写法格式 ${表达式 } 如果从作用域中取值，会先从小的作用域开始取，如果没有，就往下一个作用域取。 一直把四个作用域取完都没有， 就没有显示。 如何使用1. 取出4个作用域中存放的值。&lt;% pageContext.setAttribute(&quot;name&quot;, &quot;page&quot;); request.setAttribute(&quot;name&quot;, &quot;request&quot;); session.setAttribute(&quot;name&quot;, &quot;session&quot;); application.setAttribute(&quot;name&quot;, &quot;application&quot;); %&gt; 按普通手段取值&lt;br&gt; &lt;%= pageContext.getAttribute(&quot;name&quot;)%&gt; &lt;%= request.getAttribute(&quot;name&quot;)%&gt; &lt;%= session.getAttribute(&quot;name&quot;)%&gt; &lt;%= application.getAttribute(&quot;name&quot;)%&gt; &lt;br&gt;使用EL表达式取出作用域中的值&lt;br&gt; ${ pageScope.name } ${ requestScope.name } ${ sessionScope.name } ${ applicationScope.name } 如果域中所存的是数组 &lt;% String [] a = {&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;,&quot;dd&quot;}; pageContext.setAttribute(&quot;array&quot;, a); %&gt; 使用EL表达式取出作用域中数组的值&lt;br&gt; ${array[0] } , ${array[1] },${array[2] },${array[3] } 如果域中所存的是集合 使用EL表达式取出作用域中集合的值&lt;br&gt; ${li[0] } , ${li[1] },${li[2] },${li[3] } &lt;br&gt;-------------Map数据----------------&lt;br&gt; &lt;% Map map = new HashMap(); map.put(&quot;name&quot;, &quot;zhangsna&quot;); map.put(&quot;age&quot;,18); map.put(&quot;address&quot;,&quot;北京..&quot;); map.put(&quot;address.aa&quot;,&quot;深圳..&quot;); pageContext.setAttribute(&quot;map&quot;, map); %&gt; 取出Map集合的值 &lt;% Map map = new HashMap(); map.put(&quot;name&quot;, &quot;zhangsna&quot;); map.put(&quot;age&quot;,18); map.put(&quot;address&quot;,&quot;北京..&quot;); map.put(&quot;address.aa&quot;,&quot;深圳..&quot;); pageContext.setAttribute(&quot;map&quot;, map); %&gt; 使用EL表达式取出作用域中Map的值&lt;br&gt; ${map.name } , ${map.age } , ${map.address } , ${map[&quot;address.aa&quot;] } 取值细节： 从域中取值。 得先存值。&lt;% //pageContext.setAttribute(&quot;name&quot;, &quot;zhangsan&quot;); session.setAttribute(&quot;name&quot;, &quot;lisi...&quot;); %&gt; 直接指定说了，到这个作用域里面去找这个name${ pageScope.name } //先从page里面找，没有去request找，去session，去application ${ name } 指定从session中取值 ${ sessionScope.name } 取值方式 如果这份值是有下标的，那么直接使用[] &lt;% String [] array = {&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;} session.setAttribute(&quot;array&quot;,array); %&gt; ${ array[1] } --&gt; 这里array说的是attribute的name 如果没有下标， 直接使用 .的方式去取 &lt;% User user = new User(&quot;zhangsan&quot;,18); session.setAttribute(&quot;u&quot;, user); %&gt; ${ u.name } , ${ u.age } 一般使用EL表达式，用的比较多的，都是从一个对象中取出它的属性值，比如取出某一个学生的姓名。 EL表达式 的11个内置对象。${ 对象名.成员 } pageContext 作用域相关对象 pageScope requestScope sessionScope applicationScope 头信息相关对象 header headerValues 参数信息相关对象 param paramValues cookie全局初始化参数 initParam JSTL 全称 ： JSP Standard Tag Library jsp标准标签库 简化jsp的代码编写。 替换 &lt;%%&gt; 写法。 一般与EL表达式配合 怎么使用 导入jar文件到工程的WebContent/Web-Inf/lib jstl.jar standard.jar 在jsp页面上，使用taglib 指令，来引入标签库 注意： 如果想支持 EL表达式，那么引入的标签库必须选择1.1的版本，1.0的版本不支持EL表达式。 &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; 常用标签&lt;c:set&gt;&lt;/c:set&gt;&lt;c:if test=””&gt;&lt;/c:if&gt;&lt;c:forEach&gt;&lt;/c:forEach&gt; c:set &lt;!-- 声明一个对象name， 对象的值 zhangsan , 存储到了page（默认） ， 指定是session --&gt; &lt;c:set var=&quot;name&quot; value=&quot;zhangsan&quot; scope=&quot;session&quot;&gt;&lt;/c:set&gt; ${sessionScope.name } c:if 判断test里面的表达式是否满足，如果满足，就执行c:if标签中的输出 ， c:if 是没有else的。 &lt;c:set var=&quot;age&quot; value=&quot;18&quot; &gt;&lt;/c:set&gt; &lt;c:if test=&quot;${ age &gt; 26 }&quot;&gt; 年龄大于了26岁... &lt;/c:if&gt; &lt;c:if test=&quot;${ age &lt;= 26 }&quot;&gt; 年龄小于了26岁... &lt;/c:if&gt; ------------------------------ 定义一个变量名 flag 去接收前面表达式的值，然后存在session域中 &lt;c:if test=&quot;${ age &gt; 26 }&quot; var=&quot;flag&quot; scope=&quot;session&quot;&gt; 年龄大于了26岁... &lt;/c:if&gt; c:forEach 从1 开始遍历到10 ，得到的结果 ，赋值给 i ,并且会存储到page域中， step , 增幅为2， &lt;c:forEach begin=&quot;1&quot; end=&quot;10&quot; var=&quot;i&quot; step=&quot;2&quot;&gt; ${i } &lt;/c:forEach&gt; ----------------------------------------------- &lt;!-- items : 表示遍历哪一个对象，注意，这里必须写EL表达式。 var: 遍历出来的每一个元素用user 去接收。 --&gt; &lt;c:forEach var=&quot;user&quot; items=&quot;${list }&quot;&gt; ${user.name } ----${user.age } &lt;/c:forEach&gt; 学生信息管理系统 需求分析 先写 login.jsp , 并且搭配一个LoginServlet 去获取登录信息。 创建用户表， 里面只要有id , username 和 password 创建UserDao, 定义登录的方法 /** 该dao定义了对用户表的访问规则 */public interface UserDao { /** 这里简单就返回一个Boolean类型， 成功或者失败即可。 ​ 但是开发的时候，登录的方法，一旦成功。这里应该返回该用户的个人信息 @param userName @param password ​ @return true : 登录成功， false : 登录失败。 */boolean login(String userName , String password);} 创建UserDaoImpl , 实现刚才定义的登录方法。 public class UserDaoImpl implements UserDao { @Override public boolean login(String userName , String password) { Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try { //1. 得到连接对象 conn = JDBCUtil.getConn(); String sql = &quot;select * from t_user where username=? and password=?&quot;; //2. 创建ps对象 ps = conn.prepareStatement(sql); ps.setString(1, userName); ps.setString(2, password); //3. 开始执行。 rs = ps.executeQuery(); //如果能够成功移到下一条记录，那么表明有这个用户。 return rs.next(); } catch (SQLException e) { e.printStackTrace(); }finally { JDBCUtil.release(conn, ps, rs); } return false; } } 在LoginServlet里面访问UserDao， 判断登录结果。 以区分对待 创建stu_list.jsp , 让登录成功的时候跳转过去。 创建学生表 ， 里面字段随意。 定义学生的Dao . StuDao public interface StuDao { /** * 查询出来所有的学生信息 * @return List集合 */ List&lt;Student&gt; findAll(); } 对上面定义的StuDao 做出实现 StuDaoImpl public class StuDaoImpl implements StuDao { @Override public List&lt;Student&gt; findAll() { List&lt;Student&gt; list = new ArrayList&lt;Student&gt;(); Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try { //1. 得到连接对象 conn = JDBCUtil.getConn(); String sql = &quot;select * from t_stu&quot;; ps = conn.prepareStatement(sql); rs = ps.executeQuery(); ​ //数据多了，用对象装， 对象也多了呢？ 用集合装。 while(rs.next()){ //10 次 ，10个学生 Student stu = new Student(); stu.setId(rs.getInt(&quot;id&quot;)); stu.setAge(rs.getInt(&quot;age&quot;)); stu.setName(rs.getString(&quot;name&quot;)); stu.setGender(rs.getString(&quot;gender&quot;)); stu.setAddress(rs.getString(&quot;address&quot;)); list.add(stu); } } catch (SQLException e) { e.printStackTrace(); }finally { JDBCUtil.release(conn, ps, rs); } return list; } } 在登录成功的时候，完成三件事情。 查询所有的学生 把这个所有的学生集合存储到作用域中。 跳转到stu_list.jsp protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //提交的数据有可能有中文， 怎么处理。 request.setCharacterEncoding(&quot;UTF-8&quot;); response.setContentType(&quot;text/html;charset=utf-8&quot;); //1. 获取客户端提交的信息 String userName = request.getParameter(&quot;username&quot;); String password = request.getParameter(&quot;password&quot;); //2. 去访问dao ， 看看是否满足登录。 UserDao dao = new UserDaoImpl(); boolean isSuccess = dao.login(userName, password); //3. 针对dao的返回结果，做出响应 if(isSuccess){ //response.getWriter().write(&quot;登录成功.&quot;); //1. 查询出来所有的学生信息。 StuDao stuDao = new StuDaoImpl(); List&lt;Student&gt; list = stuDao.findAll(); //2. 先把这个集合存到作用域中。 request.getSession().setAttribute(&quot;list&quot;, list); //2. 重定向 response.sendRedirect(&quot;stu_list.jsp&quot;); }else{ response.getWriter().write(&quot;用户名或者密码错误！&quot;); } } 在stu_list.jsp中，取出域中的集合，然后使用c标签 去遍历集合。 &lt;table border=&quot;1&quot; width=&quot;700&quot;&gt; &lt;tr align=&quot;center&quot;&gt; &lt;td&gt;编号&lt;/td&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;年龄&lt;/td&gt; &lt;td&gt;性别&lt;/td&gt; &lt;td&gt;住址&lt;/td&gt; &lt;td&gt;操作&lt;/td&gt; &lt;/tr&gt; &lt;c:forEach items=&quot;${list }&quot; var=&quot;stu&quot;&gt; &lt;tr align=&quot;center&quot;&gt; &lt;td&gt;${stu.id }&lt;/td&gt; &lt;td&gt;${stu.name }&lt;/td&gt; &lt;td&gt;${stu.age }&lt;/td&gt; &lt;td&gt;${stu.gender }&lt;/td&gt; &lt;td&gt;${stu.address }&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;#&quot;&gt;更新&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;删除&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/table&gt; 总结： JSP 三大指令 page include taglib 三个动作标签 &lt;jsp:include&gt; &lt;jsp:forward&gt; &lt;jsp:param&gt; 九个内置对象 四个作用域 pageContext request session application out exception response page config ​ EL ${ 表达式 } 取4个作用域中的值 ${ name } 有11个内置对象。 pageContext pageScope requestScope sessionScope applicationScope header headerValues param paramValues cookie initParam JSTL 使用1.1的版本， 支持EL表达式， 1.0不支持EL表达式 拷贝jar包， 通过taglib 去引入标签库 &lt;c:set&gt; &lt;c:if&gt; &lt;c:forEach&gt; ​]]></content>
      <categories>
        <category>Java开发</category>
      </categories>
      <tags>
        <tag>JSP</tag>
        <tag>EL</tag>
        <tag>JSTL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cookie 和 Session]]></title>
    <url>%2F2019%2F02%2F07%2Fcookieandsession%2F</url>
    <content type="text"><![CDATA[Cookie 和 Session 中文文件下载 针对浏览器类型，对文件名字做编码处理 Firefox (Base64) , IE、Chrome … 使用的是URLEncoder /* * 如果文件的名字带有中文，那么需要对这个文件名进行编码处理 * 如果是IE ，或者 Chrome （谷歌浏览器） ，使用URLEncoding 编码 * 如果是Firefox ， 使用Base64编码 */ //获取来访的客户端类型 String clientType = request.getHeader(&quot;User-Agent&quot;); if(clientType.contains(&quot;Firefox&quot;)){ fileName = DownLoadUtil.base64EncodeFileName(fileName); }else{ //IE ，或者 Chrome （谷歌浏览器） ， //对中文的名字进行编码处理 fileName = URLEncoder.encode(fileName,&quot;UTF-8&quot;); } 请求转发和重定向重定向 /* 之前的写法 response.setStatus(302); response.setHeader(&quot;Location&quot;, &quot;login_success.html&quot;);*/ //重定向写法： 重新定位方向 参数即跳转的位置 response.sendRedirect(&quot;login_success.html&quot;); 1. 地址上显示的是最后的那个资源的路径地址 2. 请求次数最少有两次， 服务器在第一次请求后，会返回302 以及一个地址， 浏览器在根据这个地址，执行第二次访问。 3. 可以跳转到任意路径。 不是自己的工程也可以跳。 4. 效率稍微低一点， 执行两次请求。 5. 后续的请求，没法使用上一次的request存储的数据，或者 没法使用上一次的request对象，因为这是两次不同的请求。 请求转发//请求转发的写法： 参数即跳转的位置 request.getRequestDispatcher(&quot;login_success.html&quot;).forward(request, response); 1. 地址上显示的是请求servlet的地址。 返回200 ok 2. 请求次数只有一次， 因为是服务器内部帮客户端执行了后续的工作。 3. 只能跳转自己项目的资源路径 。 4. 效率上稍微高一点，因为只执行一次请求。 5. 可以使用上一次的request对象。 Cookie 饼干. 其实是一份小数据， 是服务器给客户端，并且存储在客户端上的一份小数据 应用场景 自动登录、浏览记录、购物车。 为什么要有这个Cookie http的请求是无状态。 客户端与服务器在通讯的时候，是无状态的，其实就是客户端在第二次来访的时候，服务器根本就不知道这个客户端以前有没有来访问过。 为了更好的用户体验，更好的交互 [自动登录]，其实从公司层面讲，就是为了更好的收集用户习惯[大数据] Cookie怎么用简单使用： 添加Cookie给客户端 在响应的时候，添加cookie Cookie cookie = new Cookie(&quot;aa&quot;, &quot;bb&quot;); ​ //给响应，添加一个cookie response.addCookie(cookie); 客户端收到的信息里面，响应头中多了一个字段 Set-Cookie 获取客户端带过来的Cookie //获取客户端带过来的cookie Cookie[] cookies = request.getCookies(); if(cookies != null){ for (Cookie c : cookies) { String cookieName = c.getName(); String cookieValue = c.getValue(); System.out.println(cookieName + &quot; = &quot;+ cookieValue); } } 常用方法 //关闭浏览器后，cookie就没有了。 ---&gt; 针对没有设置cookie的有效期。 // expiry： 有效 以秒计算。 //正值 ： 表示 在这个数字过后，cookie将会失效。 //负值： 关闭浏览器，那么cookie就失效， 默认值是 -1 cookie.setMaxAge(60 * 60 * 24 * 7); //赋值新的值 //cookie.setValue(newValue); //用于指定只有请求了指定的域名，才会带上该cookie cookie.setDomain(&quot;.domain.com&quot;); //只有访问该域名下的cookieDemo的这个路径地址才会带cookie cookie.setPath(&quot;/CookieDemo&quot;); 例子一 显示最近访问的时间。 判断账号是否正确 如果正确，则获取cookie。 但是得到的cookie是一个数组， 我们要从数组里面找到我们想要的对象。 如果找到的对象为空，表明是第一次登录。那么要添加cookie 如果找到的对象不为空， 表明不是第一次登录。 if(&quot;admin&quot;.equals(userName) &amp;&amp; &quot;123&quot;.equals(password)){ //获取cookie last-name --- &gt; Cookie [] cookies = request.getCookies(); //从数组里面找出我们想要的cookie Cookie cookie = CookieUtil.findCookie(cookies, &quot;last&quot;); //是第一次登录，没有cookie if(cookie == null){ Cookie c = new Cookie(&quot;last&quot;, System.currentTimeMillis()+&quot;&quot;); c.setMaxAge(60*60); //一个小时 response.addCookie(c); response.getWriter().write(&quot;欢迎您, &quot;+userName); }else{ //1. 去以前的cookie第二次登录，有cookie long lastVisitTime = Long.parseLong(cookie.getValue()); //2. 输出到界面， response.getWriter().write(&quot;欢迎您, &quot;+userName +&quot;,上次来访时间是：&quot;+new Date(lastVisitTime)); ​​ //3. 重置登录的时间​ cookie.setValue(System.currentTimeMillis()+””);​ response.addCookie(cookie);​ }​ }else{​ response.getWriter().write(“登陆失败 “);​ } 例子二： 显示商品浏览记录。准备工作 拷贝第一天的 html原型文件，到工程的WebContent里面。 在WebContent目录下新建一个jsp文件， product_list.jsp, 然后拷贝原来product_list.html的内容到jsp里面。 建好之后，jsp里面的所有ISO-8859-1 改成 UTF-8 拷贝html标签的所有内容。 替换jsp的html标签即可 修改product_info.html里面的手机数码超链接地址 &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;product_list.jsp&quot;&gt;手机数码&lt;span class=&quot;sr-only&quot;&gt;(current)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; 修改首页(index.html)顶部的手机数码跳转的位置为 product_list.jsp &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;product_list.jsp&quot;&gt;手机数码&lt;span class=&quot;sr-only&quot;&gt;(current)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; 分析 Jsp 里面使用Java代码 jsp Java Server Pager —&gt; 最终会翻译成一个类， 就是一个Servlet 定义全局变量 &lt;%! int a = 99; %&gt; 定义局部变量 &lt;% int b = 999; %&gt; 在jsp页面上，显示 a 和 b的值， &lt;%=a %&gt; &lt;%=b %&gt; jsp显示浏览记录 清除浏览记录 其实就是清除Cookie， 删除cookie是没有什么delete方法的。只有设置maxAge 为0 。 Cookie cookie = new Cookie(&quot;history&quot;,&quot;&quot;); cookie.setMaxAge(0); //设置立即删除 cookie.setPath(&quot;/CookieDemo02&quot;); response.addCookie(cookie); Cookie总结 服务器给客户端发送过来的一小份数据，并且存放在客户端上。 获取cookie， 添加cookie request.getCookie(); response.addCookie(); Cookie分类 会话Cookie 默认情况下，关闭了浏览器，那么cookie就会消失。 持久Cookie 在一定时间内，都有效，并且会保存在客户端上。 cookie.setMaxAge(0); //设置立即删除 cookie.setMaxAge(100); //100 秒 Cookie的安全问题。 由于Cookie会保存在客户端上，所以有安全隐患问题。 还有一个问题， Cookie的大小与个数有限制。 为了解决这个问题 —&gt; Session . Session 会话 ， Session是基于Cookie的一种会话机制。 Cookie是服务器返回一小份数据给客户端，并且存放在客户端上。 Session是，数据存放在服务器端。 常用API //得到会话ID String id = session.getId(); //存值 session.setAttribute(name, value); //取值 session.getAttribute(name); //移除值 session.removeAttribute(name); Session何时创建 ， 何时销毁? 创建 如果有在servlet里面调用了 request.getSession() 销毁 session 是存放在服务器的内存中的一份数据。 当然可以持久化. Redis . 即使关了浏览器，session也不会销毁。 关闭服务器 session会话时间过期。 有效期过了，默认有效期： 30分钟。 例子三： 简单购物车。 CartServlet 代码response.setContentType(&quot;text/html;charset=utf-8&quot;); //1. 获取要添加到购物车的商品id int id = Integer.parseInt(request.getParameter(&quot;id&quot;)); // 0 - 1- 2 -3 -4 String [] names = {&quot;Iphone7&quot;,&quot;小米6&quot;,&quot;三星Note8&quot;,&quot;魅族7&quot; , &quot;华为9&quot;}; //取到id对应的商品名称 String name = names[id]; //2. 获取购物车存放东西的session Map&lt;String , Integer&gt; iphoen7 3 //把一个map对象存放到session里面去，并且保证只存一次。 Map&lt;String, Integer&gt; map = (Map&lt;String, Integer&gt;) request.getSession().getAttribute(&quot;cart&quot;); //session里面没有存放过任何东西。 if(map == null){ map = new LinkedHashMap&lt;String , Integer&gt;(); request.getSession().setAttribute(&quot;cart&quot;, map); } ​​ //3. 判断购物车里面有没有该商品​ if(map.containsKey(name)){​ //在原来的值基础上 + 1​ map.put(name, map.get(name) + 1 );​ }else{​ //没有购买过该商品，当前数量为1 。​ map.put(name, 1);​ }​ //4. 输出界面。（跳转） response.getWriter().write(“继续购物“); response.getWriter().write(“去购物车结算“); 移除Session中的元素//强制干掉会话，里面存放的任何数据就都没有了。 session.invalidate(); //从session中移除某一个数据 //session.removeAttribute(&quot;cart&quot;); 总结： 请求转发和重定向（面试经常问。） Cookie 服务器给客户端发送一小份数据， 存放在客户端上。 基本用法： 添加cookie 获取cookie。 演练例子： 1. 获取上一次访问时间 2. 获取商品浏览记录。 什么时候有cookie response.addCookie(new Cookie()) Cookie 分类 会话Cookie 关闭浏览器，就失效 持久cookie 存放在客户端上。 在指定的期限内有效。 setMaxAge(); Session 也是基于cookie的一种会话技术， 数据存放存放在服务器端 会在cookie里面添加一个字段 JSESSIONID . 是tomcat服务器生成。 setAttribute 存数据 getAttribute 取数据 removeAttribute 移除数据 getSessionId(); 获取会话id invalidate() 强制让会话失效。 创建和销毁 ，调用request.getSesion创建 服务器关闭 ， 会话超时（30分） setAttribute 存放的值， 在浏览器关闭后，还有没有。 有！，就算客户端把电脑砸了也还有。 ​]]></content>
      <categories>
        <category>Java开发</category>
      </categories>
      <tags>
        <tag>Cookie</tag>
        <tag>Session</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HttpServletRequest 和 HttpServletResponse]]></title>
    <url>%2F2019%2F02%2F02%2Fhttpservletrequestandhttpservletresponse%2F</url>
    <content type="text"><![CDATA[HttpServletRequest 和 HttpServletResponse Servlet配置方式 全路径匹配 以 / 开始 /a /aa/bb localhost:8080/项目名称/aa/bb 路径匹配 , 前半段匹配 以 / 开始 ， 但是以 结束 /a/ /* 其实是一个通配符，匹配任意文字 localhost:8080/项目名称/aa/bb 以扩展名匹配 写法： 没有/ 以 开始 .扩展名 .aa .bb ServletContext Servlet 上下文 每个web工程都只有一个ServletContext对象。 说白了也就是不管在哪个servlet里面，获取到的这个类的对象都是同一个。 如何得到对象//1. 获取对象 ServletContext context = getServletContext(); 有什么作用 获取全局配置参数 获取web工程中的资源 存取数据，servlet间共享数据 域对象 可以获取全局配置参数 获取全局参数 可以获取Web应用中的资源1. 获取资源在tomcat里面的绝对路径 先得到路径，然后自己new InpuStream context.getRealPath(&quot;&quot;) //这里得到的是项目在tomcat里面的根目录。 D:\tomcat\apache-tomcat-7.0.52\apache-tomcat-7.0.52\wtpwebapps\Demo03\ String path = context.getRealPath(&quot;file/config.properties&quot;); D:\tomcat\apache-tomcat-7.0.52\apache-tomcat-7.0.52\wtpwebapps\Demo03\file\config.properties 2. getResourceAsStream 获取资源 流对象 直接给相对的路径，然后获取流对象。 通过classloader去获取web工程下的资源 使用ServletContext存取数据。 定义一个登陆的html页面， 定义一个form表单 定义一个Servlet，名为LoginServlet 针对成功或者失败，进行判断，然后跳转到不一样的网页 ServletContext存取值分析 细节：&lt;!-- A路径： Servlet的路径 http://localhost:8080/Demo4/login B路径： 当前这个html的路径： http://localhost:8080/Demo4/login.html --&gt; ​​ ​ 账号:​ 密码:​ ​ ServletContext 何时创建， 何时销毁?服务器启动的时候，会为托管的每一个web应用程序，创建一个ServletContext对象 从服务器移除托管，或者是关闭服务器。 ServletContext 的作用范围 只要在这个项目里面，都可以取。 只要同一个项目。 A项目 存， 在B项目取，是取不到的？ ServletContext对象不同。 HttpServletRequest 这个对象封装了客户端提交过来的一切数据。 可以获取客户端请求头信息 //得到一个枚举集合 Enumeration&lt;String&gt; headerNames = request.getHeaderNames(); while (headerNames.hasMoreElements()) { String name = (String) headerNames.nextElement(); String value = request.getHeader(name); System.out.println(name+&quot;=&quot;+value); } 获取客户端提交过来的数据 String name = request.getParameter(&quot;name&quot;); String address = request.getParameter(&quot;address&quot;); System.out.println(&quot;name=&quot;+name); System.out.println(&quot;address=&quot;+address); ------------------------------------------------- //name=zhangsan&amp;name=lisi&amp;name=wangwu 一个key可以对应多个值。 Map&lt;String, String[]&gt; map = request.getParameterMap(); Set&lt;String&gt; keySet = map.keySet(); Iterator&lt;String&gt; iterator = keySet.iterator(); while (iterator.hasNext()) { String key = (String) iterator.next(); System.out.println(&quot;key=&quot;+key + &quot;--的值总数有：&quot;+map.get(key).length); String value = map.get(key)[0]; String value1 = map.get(key)[1]; String value2 = map.get(key)[2]; System.out.println(key+&quot; ======= &quot;+ value + &quot;=&quot; + value1 + &quot;=&quot;+ value2); } 获取中文数据 客户端提交数据给服务器端，如果数据中带有中文的话，有可能会出现乱码情况，那么可以参照以下方法解决。 如果是GET方式 代码转码 String username = request.getParameter(&quot;username&quot;); String password = request.getParameter(&quot;password&quot;); System.out.println(&quot;userName=&quot;+username+&quot;==password=&quot;+password); //get请求过来的数据，在url地址栏上就已经经过编码了，所以我们取到的就是乱码， //tomcat收到了这批数据，getParameter 默认使用ISO-8859-1去解码 //先让文字回到ISO-8859-1对应的字节数组 ， 然后再按utf-8组拼字符串 username = new String(username.getBytes(&quot;ISO-8859-1&quot;) , &quot;UTF-8&quot;); System.out.println(&quot;userName=&quot;+username+&quot;==password=&quot;+password); 直接在tomcat里面做配置，以后get请求过来的数据永远都是用UTF-8编码。 2. 可以在tomcat里面做设置处理 conf/server.xml 加上URIEncoding=&quot;utf-8&quot; &lt;Connector connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot; URIEncoding=&quot;UTF-8&quot;/&gt; 如果是POST方式 这个说的是设置请求体里面的文字编码。 get方式，用这行，有用吗？ ---&gt; 没用 request.setCharacterEncoding(&quot;UTF-8&quot;); 这行设置一定要写在getParameter之前。 HttpServletResponse 负责返回数据给客户端。 输出数据到页面上 //以字符流的方式写数据 //response.getWriter().write(&quot;&lt;h1&gt;hello response...&lt;/h1&gt;&quot;); //以字节流的方式写数据 response.getOutputStream().write(&quot;hello response2222...&quot;.getBytes()); 响应的数据中有中文，那么有可能出现中文乱码 以字符流输出 response.getWriter() //1. 指定输出到客户端的时候，这些文字使用UTF-8编码 response.setCharacterEncoding(&quot;UTF-8&quot;); //2. 直接规定浏览器看这份数据的时候，使用什么编码来看。 response.setHeader(&quot;Content-Type&quot;, &quot;text/html; charset=UTF-8&quot;); response.getWriter().write(&quot;我爱训练营...&quot;); 以字节流输出 response.getOutputStream() ​​​ //1. 指定浏览器看这份数据使用的码表​ response.setHeader(“Content-Type”, “text/html;charset=UTF-8”);​​ //2. 指定输出的中文用的码表​ response.getOutputStream().write(“我爱训练营..”.getBytes(“UTF-8”)); -------------------------------------------- 不管是字节流还是字符流，直接使用一行代码就可以了。response.setContentType(&quot;text/html;charset=UTF-8&quot;); 然后在写数据即可。 演练下载资源。 直接以超链接的方式下载，不写任何代码。 也能够下载东西下来。 让tomcat的默认servlet去提供下载：&lt;br&gt; &lt;a href=&quot;download/aa.jpg&quot;&gt;aa.jpg&lt;/a&gt;&lt;br&gt; &lt;a href=&quot;download/bb.txt&quot;&gt;bb.txt&lt;/a&gt;&lt;br&gt; &lt;a href=&quot;download/cc.rar&quot;&gt;cc.rar&lt;/a&gt;&lt;br&gt; 原因是tomcat里面有一个默认的Servlet – DefaultServlet 。这个DefaultServlet 专门用于处理放在tomcat服务器上的静态资源。 总结 Servlet注册方式 ServletContext【重点】 作用： 1. 获取全局参数 2. 获取工程里面的资源。 3. 资源共享。 ServletContext 域对象 有几个 一个 什么时候创建 ？ 什么时候销毁 服务器启动的时候给每一个应用都创建一个ServletContext对象， 服务器关闭的时候销毁 简单登录 HttpServletRequest【重点】 获取请求头 获取提交过来的数据 HttpServletResponse【重点】 负责输出数据到客户端，其实就是对之前的请求作出响应 中文乱码问题。【重点】 下载 练习：1. 完成注册 2. 完成登录 V1.1 最好配合上数据库，完成注册和登录的功能。 ​]]></content>
      <categories>
        <category>Java开发</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet]]></title>
    <url>%2F2019%2F02%2F02%2Fservlet%2F</url>
    <content type="text"><![CDATA[Servlet Servlet servlet是什么? 其实就是一个java程序，运行在我们的web服务器上，用于接收和响应 客户端的http请求。 更多的是配合动态资源来做。 当然静态资源也需要使用到servlet，只不过是Tomcat里面已经定义好了一个 DefaultServlet Hello Servlet 得写一个Web工程 ， 要有一个服务器。 测试运行Web工程 新建一个类， 实现Servlet接口 配置Servlet ， 用意： 告诉服务器，我们的应用有这么些个servlet。 在webContent/WEB-INF/web.xml里面写上以下内容。 &lt;!-- 向tomcat报告， 我这个应用里面有这个servlet， 名字叫做HelloServlet , 具体的路径是com.domain.servlet.HelloServlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.domain.servlet.HelloServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;!-- 注册servlet的映射。 servletName : 找到上面注册的具体servlet， url-pattern: 在地址栏上的path 一定要以/打头 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/a&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 3. 在地址栏上输入 http://localhost:8080/项目名称/a Servlet执行过程 Servlet的通用写法Servlet (接口) | | GenericServlet | | HttpServlet （用于处理http的请求） 定义一个类，继承HttpServlet 复写doGet 和 doPost Servlet的生命周期 生命周期 从创建到销毁的一段时间 生命周期方法 从创建到销毁，所调用的那些方法。 init方法 在创建该servlet的实例时，就执行该方法。 一个servlet只会初始化一次， init方法只会执行一次 默认情况下是 ： 初次访问该servlet，才会创建实例。 service方法 只要客户端来了一个请求，那么就执行这个方法了。 该方法可以被执行很多次。 一次请求，对应一次service方法的调用 destroy方法 servlet销毁的时候，就会执行该方法 1. 该项目从tomcat的里面移除。 2. 正常关闭tomcat就会执行 shutdown.bat doGet 和 doPost不算生命周期方法，所谓的生命周期方法是指，从对象的创建到销毁一定会执行的方法， 但是这两个方法，不一定会执行。 让Servlet创建实例的时机提前。 默认情况下，只有在初次访问servlet的时候，才会执行init方法。 有的时候，我们可能需要在这个方法里面执行一些初始化工作，甚至是做一些比较耗时的逻辑。 那么这个时候，初次访问，可能会在init方法中逗留太久的时间。 那么有没有方法可以让这个初始化的时机提前一点。 在配置的时候， 使用load-on-startup元素来指定， 给定的数字越小，启动的时机就越早。 一般不写负数， 从2开始即可。 &lt;servlet&gt; &lt;servlet-name&gt;HelloServlet04&lt;/servlet-name&gt; &lt;servlet-class&gt;com.domain.servlet.HelloServlet04&lt;/servlet-class&gt; &lt;load-on-startup&gt;2&lt;/load-on-startup&gt; &lt;/servlet&gt; ServletConfig Servlet的配置，通过这个对象，可以获取servlet在配置的时候一些信息 先说 ， 在写怎么用， 最后说有什么用。 //1. 得到servlet配置对象 专门用于在配置servlet的信息 ServletConfig config = getServletConfig(); //获取到的是配置servlet里面servlet-name 的文本内容 String servletName = config.getServletName(); System.out.println(&quot;servletName=&quot;+servletName); ​ //2、。 可以获取具体的某一个参数。 String address = config.getInitParameter(“address”); System.out.println(“address=”+address); //3.获取所有的参数名称 Enumeration&lt;String&gt; names = config.getInitParameterNames(); //遍历取出所有的参数名称 while (names.hasMoreElements()) { String key = (String) names.nextElement(); String value = config.getInitParameter(key); System.out.println(&quot;key===&quot;+key + &quot; value=&quot;+value); } 为什么需要有这个ServletConfig 未来我们自己开发的一些应用，使用到了一些技术，或者一些代码，我们不会。 但是有人写出来了。它的代码放置在了自己的servlet类里面。 刚好这个servlet 里面需要一个数字或者叫做变量值。 但是这个值不能是固定了。 所以要求使用到这个servlet的公司，在注册servlet的时候，必须要在web.xml里面，声明init-params 在开发当中比较少用。 总结 Servlet【重点】 会使用简单的servlet 1.写一个类，实现接口Servlet 2. 配置Servlet 3. 会访问Setvlet Servlet的生命周期 init 一次 创建对象 默认初次访问就会调用或者可以通过配置，让它提前 load-on-startupservice 多次，一次请求对应一次servicedestory 一次 销毁的时候 从服务器移除 或者 正常关闭服务器 ServletConfig 获取配置的信息， params]]></content>
      <categories>
        <category>Java开发</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP协议]]></title>
    <url>%2F2019%2F02%2F02%2Fhttp%2F</url>
    <content type="text"><![CDATA[HTTP协议 HTTP协议 什么是协议 双方在交互、通讯的时候， 遵守的一种规范、规则。 http协议 针对网络上的客户端 与 服务器端在执行http请求的时候，遵守的一种规范。 其实就是规定了客户端在访问服务器端的时候，要带上哪些东西， 服务器端返回数据的时候，也要带上什么东西。 版本 1.0 请求数据，服务器返回后， 将会断开连接 1.1 请求数据，服务器返回后， 连接还会保持着。 除非服务器 | 客户端 关掉。 有一定的时间限制，如果都空着这个连接，那么后面会自己断掉。 演示客户端 如何 与服务器端通讯。 在地址栏中键入网络地址 回车 或者是平常注册的时候，点击了注册按钮 ， 浏览器都能显示出来一些东西。那么背地里到底浏览器和服务器是怎么通讯。 它们都传输了哪些数据。 安装抓包工具 HttpWatch (IE插件) 打开tomcat. 输入localhost:8080 打开首页 在首页上找到Example 字样 6.x 和 7.x 的文档页面有所不同，但是只要找到example就能够找到例子工程 选择 servlet 例子 —&gt; Request Parameter 接着点击Request Parameters 的 Execute超链接 执行tomcat的例子，然后查看浏览器和 tomcat服务器的对接细节 Http请求数据解释 请求的数据里面包含三个部分内容 ： 请求行 、 请求头 、请求体 请求行 POST /examples/servlets/servlet/RequestParamExample HTTP/1.1 POST ： 请求方式 ，以post去提交数据 /examples/servlets/servlet/RequestParamExample 请求的地址路径 ， 就是要访问哪个地方。 HTTP/1.1 协议版本 请求头 Accept: application/x-ms-application, image/jpeg, application/xaml+xml, image/gif, image/pjpeg, application/x-ms-xbap, */* Referer: http://localhost:8080/examples/servlets/servlet/RequestParamExample Accept-Language: zh-CN User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E) Content-Type: application/x-www-form-urlencoded Accept-Encoding: gzip, deflate Host: localhost:8080 Content-Length: 31 Connection: Keep-Alive Cache-Control: no-cache Accept: 客户端向服务器端表示，我能支持什么类型的数据。 Referer ： 真正请求的地址路径，全路径 Accept-Language: 支持语言格式 User-Agent: 用户代理 向服务器表明，当前来访的客户端信息。 Content-Type： 提交的数据类型。经过urlencoding编码的form表单的数据 Accept-Encoding： gzip, deflate ： 压缩算法 。 Host ： 主机地址 Content-Length： 数据长度 Connection : Keep-Alive 保持连接 Cache-Control ： 对缓存的操作 请求体 浏览器真正发送给服务器的数据 发送的数据呈现的是key=value ,如果存在多个数据，那么使用 &amp; firstname=zhang&amp;lastname=sansan Http响应数据解析 请求的数据里面包含三个部分内容 ： 响应行 、 响应头 、响应体 HTTP/1.1 200 OK Server: Apache-Coyote/1.1 Content-Type: text/html;charset=ISO-8859-1 Content-Length: 673 Date: Fri, 17 Feb 2017 02:53:02 GMT ...这里还有很多数据... 响应行 HTTP/1.1 200 OK 协议版本 状态码 咱们这次交互到底是什么样结果的一个code. 200 : 成功，正常处理，得到数据。 403 : for bidden 拒绝 404 ： Not Found 500 ： 服务器异常 OK 对应前面的状态码 响应头 Server: 服务器是哪一种类型。 Tomcat Content-Type ： 服务器返回给客户端你的内容类型 Content-Length ： 返回的数据长度 Date ： 通讯的日期，响应的时间 Get 和 Post请求区别 post 1. 数据是以流的方式写过去，不会在地址栏上面显示。 现在一般提交数据到服务器使用的都是POST 2. 以流的方式写数据，所以数据没有大小限制。 get 1. 会在地址栏后面拼接数据，所以有安全隐患。 一般从服务器获取数据，并且客户端也不用提交上面数据的时候，可以使用GET 2. 能够带的数据有限， 1kb大小 Web资源在http协议当中，规定了请求和响应双方， 客户端和服务器端。与web相关的资源。 有两种分类 静态资源 html 、 js、 css 动态资源 servlet/jsp 总结 Http协议 使用HttpWacht 抓包看一看http请求背后的细节。 基本了解 请求和响应的数据内容 请求行、 请求头 、请求体 响应行、响应头、响应体 Get和Post的区别]]></content>
      <categories>
        <category>协议</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat]]></title>
    <url>%2F2019%2F01%2F31%2Ftomcat%2F</url>
    <content type="text"><![CDATA[Tomcat 程序架构网页游戏 C/S(client/server) QQ 微信 LOL 优点： 有一部分代码写在客户端， 用户体验比较好。 缺点： 服务器更新，客户端也要随着更新。 占用资源大。 B/S(browser/server) 网页游戏 ， WebQQ … 优点： 客户端只要有浏览器就可以了。 占用资源小， 不用更新。 缺点： 用户体验不佳。 服务器 其实服务器就是一台电脑。 配置比一般的要好。 Web服务器软件 客户端在浏览器的地址栏上输入地址 ，然后web服务器软件，接收请求，然后响应消息。处理客户端的请求， 返回资源 | 信息 Web应用 需要服务器支撑。 index.html Tomcat apache WebLogic BEA Websphere IBM IIS 微软 Tomcat安装 直接解压 ，然后找到bin/startup.bat 可以安装 启动之后，如果能够正常看到黑窗口，表明已经成功安装。 为了确保万无一失， 最好在浏览器的地址栏上输入 ： http://localhost:8080 , 如果有看到内容 就表明成功了。 如果双击了startup.bat, 看到一闪而过的情形，一般都是 JDK的环境变量没有配置。 Tomcat目录介绍bin## 包含了一些jar , bat文件 。 startup.bat conf## 1tomcat的配置 server.xml web.xml lib tomcat运行所需的jar文件 logs 运行的日志文件 temp 临时文件 webapps## 发布到tomcat服务器上的项目，就存放在这个目录。 work jsp翻译成class文件存放地 如何把一个项目发布到tomcat中 需求： 如何能让其他的电脑访问我这台电脑上的资源 。 stu.xml localhost : 本机地址 1. 拷贝这个文件到webapps/ROOT底下， 在浏览器里面访问： http://localhost:8080/stu.xml * 在webaps下面新建一个文件夹xml , 然后拷贝文件放置到这个文件夹中 ​​ http://localhost:8080/xml/stu.xml​ http://localhost:8080 ： 其实对应的是到webapps/root http://localhost:8080/xml/ : 对应是 webapps/xml 使用IP地址访问： http://192.168.37.48:8080/xml/stu.xml 2. 配置虚拟路径使用localhost：8080 打开tomcat首页， 在左侧找到tomcat的文档入口， 点击进去后， 在左侧接着找到 Context入口，点击进入。 http://localhost:8080/docs/config/context.html 在conf/server.xml 找到host元素节点。 加入以下内容。 &lt;!-- docBase ： 项目的路径地址 如： D:\xml02\person.xml path : 对应的虚拟路径 一定要以/打头。 对应的访问方式为： http://localhost:8080/a/person.xml --&gt; &lt;Context docBase=&quot;D:\xml02&quot; path=&quot;/a&quot;&gt;&lt;/Context&gt; 在浏览器地址栏上输入： http://localhost:8080/a/person.xml 3. 配置虚拟路径 在tomcat/conf/catalina/localhost/ 文件夹下新建一个xml文件，名字可以自己定义。 person.xml 在这个文件里面写入以下内容 &lt;?xml version=’1.0’ encoding=’utf-8’?&gt; &lt;Context docBase=&quot;D:\xml02&quot;&gt;&lt;/Context&gt; 在浏览器上面访问 http://localhost:8080/person/xml的名字即可 给Eclipse配置Tomcat 在server里面 右键新建一个服务器， 选择到apache分类， 找到对应的tomcat版本， 接着一步一步配置即可。 配置完毕后， 在server 里面， 右键刚才的服务器，然后open ， 找到上面的Server Location , 选择中间的 Use Tomcat installation… 创建web工程， 在WebContent下定义html文件， 右键工程， run as server 总结：tomcat 1. 会安装 ，会启动 ， 会访问。 2. 会设置虚拟路径 3. 给eclipse配置tomcat]]></content>
      <categories>
        <category>Java开发</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XML]]></title>
    <url>%2F2019%2F01%2F29%2Fxml%2F</url>
    <content type="text"><![CDATA[XML eXtendsible markup language 可扩展的标记语言 XML 有什么用? 可以用来保存数据 可以用来做配置文件 数据传输载体 定义xml 其实就是一个文件，文件的后缀为 .xml 文档声明简单声明， version : 解析这个xml的时候，使用什么版本的解析器解析 &lt;?xml version=&quot;1.0&quot; ?&gt; encoding : 解析xml中的文字的时候，使用什么编码来翻译 &lt;?xml version=&quot;1.0&quot; encoding=&quot;gbk&quot; ?&gt; standalone : no - 该文档会依赖关联其他文档 ， yes-- 这是一个独立的文档 &lt;?xml version=&quot;1.0&quot; encoding=&quot;gbk&quot; standalone=&quot;no&quot; ?&gt; encoding详解 在解析这个xml的时候，使用什么编码去解析。 —解码。 文字， 而是存储这些文字对应的二进制 。 那么这些文字对应的二进制到底是多少呢？ 根据文件使用的编码 来得到。 默认文件保存的时候，使用的是GBK的编码保存。 所以要想让我们的xml能够正常的显示中文，有两种解决办法 让encoding也是GBK 或者 gb2312 . 如果encoding是 utf-8 ， 那么保存文件的时候也必须使用utf-8 保存的时候见到的ANSI 对应的其实是我们的本地编码 GBK。 为了通用，建议使用UTF-8编码保存，以及encoding 都是 utf-8 元素定义（标签） 其实就是里面的标签， &lt;&gt; 括起来的都叫元素 。 成对出现。 如下： &lt;stu&gt; &lt;/stu&gt; 文档声明下来的第一个元素叫做根元素 (根标签) 标签里面可以嵌套标签 空标签 既是开始也是结束。 一般配合属性来用。 &lt;age/&gt; &lt;stu&gt; &lt;name&gt;张三&lt;/name&gt; &lt;age/&gt; &lt;/stu&gt; 标签可以自定义。 XML 命名规则 XML 元素必须遵循以下命名规则： 名称可以含字母、数字以及其他的字符 名称不能以数字或者标点符号开始 名称不能以字符 “xml”（或者 XML、Xml）开始 名称不能包含空格 命名尽量简单，做到见名知义 简单元素 &amp; 复杂元素 简单元素 元素里面包含了普通的文字 复杂元素 元素里面还可以嵌套其他的元素 属性的定义 定义在元素里面， &lt;元素名称 属性名称=”属性的值”&gt;&lt;/元素名称&gt; 张三 18 李四 28 xml注释： 与html的注释一样。 &lt;!-- --&gt; 如： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!-- //这里有两个学生 //一个学生，名字叫张三， 年龄18岁， 学号：10086 //另外一个学生叫李四 。。。 --&gt; xml的注释，不允许放置在文档的第一行。 必须在文档声明的下面。 CDATA区 非法字符 严格地讲，在 XML 中仅有字符 “&lt;”和”&amp;” 是非法的。省略号、引号和大于号是合法的，但是把它们替换为实体引用是个好的习惯。 &lt; &lt;&amp; &amp; 如果某段字符串里面有过多的字符， 并且里面包含了类似标签或者关键字的这种文字，不想让xml的解析器去解析。 那么可以使用CDATA来包装。 不过这个CDATA 一般比较少看到。 通常在服务器给客户端返回数据的时候。 &lt;des&gt;&lt;![CDATA[&lt;a href=&quot;http://www.baidu.com&quot;&gt;我爱学习&lt;/a&gt;]]&gt;&lt;/des&gt; XML 解析 其实就是获取元素里面的字符数据或者属性数据。 XML解析方式(面试常问) 有很多种，但是常用的有两种。 DOM SAX 针对这两种解析方式的API 一些组织或者公司， 针对以上两种解析方式， 给出的解决方案有哪些？ jaxp sun公司。 比较繁琐 jdom dom4j 使用比较广泛 Dom4j 基本用法element.element(&quot;stu&quot;) : 返回该元素下的第一个stu元素 element.elements(); 返回该元素下的所有子元素。 创建SaxReader对象 指定解析的xml 获取根元素。 根据根元素获取子元素或者下面的子孙元素 try { //1. 创建sax读取对象 SAXReader reader = new SAXReader(); //jdbc -- classloader //2. 指定解析的xml源 Document document = reader.read(new File(&quot;src/xml/stus.xml&quot;)); //3. 得到元素、 //得到根元素 Element rootElement= document.getRootElement(); //获取根元素下面的子元素 age //rootElement.element(&quot;age&quot;) //System.out.println(rootElement.element(&quot;stu&quot;).element(&quot;age&quot;).getText()); //获取根元素下面的所有子元素 。 stu元素 List&lt;Element&gt; elements = rootElement.elements(); //遍历所有的stu元素 for (Element element : elements) { //获取stu元素下面的name元素 String name = element.element(&quot;name&quot;).getText(); String age = element.element(&quot;age&quot;).getText(); String address = element.element(&quot;address&quot;).getText(); System.out.println(&quot;name=&quot;+name+&quot;==age+&quot;+age+&quot;==address=&quot;+address); } } catch (Exception e) { e.printStackTrace(); } SaxReader 创建好对象 。 DocumentElement 看文档 记住关键字 。 有对象先点一下。 看一下方法的返回值。 根据平时的积累。 getXXX setXXX Dom4j 的 Xpath使用 dom4j里面支持Xpath的写法。 xpath其实是xml的路径语言，支持我们在解析xml的时候，能够快速的定位到具体的某一个元素。 添加jar包依赖 jaxen-1.1-beta-6.jar 在查找指定节点的时候，根据XPath语法规则来查找 后续的代码与以前的解析代码一样。 //要想使用Xpath， 还得添加支持的jar 获取的是第一个 只返回一个。 Element nameElement = (Element) rootElement.selectSingleNode(&quot;//name&quot;); System.out.println(nameElement.getText()); System.out.println(&quot;----------------&quot;); //获取文档里面的所有name元素 List&lt;Element&gt; list = rootElement.selectNodes(&quot;//name&quot;); for (Element element : list) { System.out.println(element.getText()); } XML 约束【了解】如下的文档， 属性的ID值是一样的。 这在生活中是不可能出现的。 并且第二个学生的姓名有好几个。 一般也很少。那么怎么规定ID的值唯一， 或者是元素只能出现一次，不能出现多次？ 甚至是规定里面只能出现具体的元素名字。 &lt;stus&gt; &lt;stu id=&quot;10086&quot;&gt; &lt;name&gt;张三&lt;/name&gt; &lt;age&gt;18&lt;/age&gt; &lt;address&gt;深圳&lt;/address&gt; &lt;/stu&gt; &lt;stu id=&quot;10086&quot;&gt; &lt;name&gt;李四&lt;/name&gt; &lt;name&gt;李五&lt;/name&gt; &lt;name&gt;李六&lt;/name&gt; &lt;age&gt;28&lt;/age&gt; &lt;address&gt;北京&lt;/address&gt; &lt;/stu&gt; &lt;/stus&gt; DTD语法自成一派， 早起就出现的。 可读性比较差。 引入网络上的DTD &lt;!-- 引入dtd 来约束这个xml --&gt; &lt;!-- 文档类型 根标签名字 网络上的dtd dtd的名称 dtd的路径 &lt;!DOCTYPE stus PUBLIC &quot;//UNKNOWN/&quot; &quot;unknown.dtd&quot;&gt; --&gt; 引入本地的DTD 直接在XML里面嵌入DTD的约束规则 &lt;!-- xml文档里面直接嵌入DTD的约束法则 --&gt; &lt;!DOCTYPE stus [ &lt;!ELEMENT stus (stu)&gt; &lt;!ELEMENT stu (name,age)&gt; &lt;!ELEMENT name (#PCDATA)&gt; &lt;!ELEMENT age (#PCDATA)&gt; ]&gt; &lt;stus&gt; &lt;stu&gt; &lt;name&gt;张三&lt;/name&gt; &lt;age&gt;18&lt;/age&gt; &lt;/stu&gt; &lt;/stus&gt; &lt;!ELEMENT stus (stu)&gt; : stus 下面有一个元素 stu ， 但是只有一个 &lt;!ELEMENT stu (name , age)&gt; stu下面有两个元素 name ,age 顺序必须name-age &lt;!ELEMENT name (#PCDATA)&gt; &lt;!ELEMENT age (#PCDATA)&gt; &lt;!ATTLIST stu id CDATA #IMPLIED&gt; stu有一个属性 文本类型， 该属性可有可无 元素的个数： ＋ 一个或多个 * 零个或多个 ? 零个或一个 属性的类型定义 CDATA : 属性是普通文字 ID : 属性的值必须唯一 &lt;!ELEMENT stu (name , age)&gt; 按照顺序来 &lt;!ELEMENT stu (name | age)&gt; 两个中只能包含一个子元素 Schema其实就是一个xml ， 使用xml的语法规则， xml解析器解析起来比较方便 ， 是为了替代DTD 。 但是Schema 约束文本内容比DTD的内容还要多。 所以目前也没有真正意义上的替代DTD 约束文档： &lt;!-- xmlns : xml namespace : 名称空间 / 命名空间 targetNamespace : 目标名称空间 。 下面定义的那些元素都与这个名称空间绑定上。 elementFormDefault ： 元素的格式化情况。 --&gt; &lt;schema xmlns=&quot;http://www.w3.org/2001/XMLSchema&quot; targetNamespace=&quot;http://www.itheima.com/teacher&quot; elementFormDefault=&quot;qualified&quot;&gt; &lt;element name=&quot;teachers&quot;&gt; &lt;complexType&gt; &lt;sequence maxOccurs=&quot;unbounded&quot;&gt; &lt;!-- 这是一个复杂元素 --&gt; &lt;element name=&quot;teacher&quot;&gt; &lt;complexType&gt; &lt;sequence&gt; &lt;!-- 以下两个是简单元素 --&gt; &lt;element name=&quot;name&quot; type=&quot;string&quot;&gt;&lt;/element&gt; &lt;element name=&quot;age&quot; type=&quot;int&quot;&gt;&lt;/element&gt; &lt;/sequence&gt; &lt;/complexType&gt; &lt;/element&gt; &lt;/sequence&gt; &lt;/complexType&gt; &lt;/element&gt; &lt;/schema&gt; 实例文档： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!-- xmlns:xsi : 这里必须是这样的写法，也就是这个值已经固定了。 xmlns : 这里是名称空间，也固定了，写的是schema里面的顶部目标名称空间 xsi:schemaLocation : 有两段： 前半段是名称空间，也是目标空间的值 ， 后面是约束文档的路径。 --&gt; &lt;teachers xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://www.itheima.com/teacher&quot; xsi:schemaLocation=&quot;http://www.itheima.com/teacher teacher.xsd&quot; &gt; &lt;teacher&gt; &lt;name&gt;zhangsan&lt;/name&gt; &lt;age&gt;19&lt;/age&gt; &lt;/teacher&gt; &lt;teacher&gt; &lt;name&gt;lisi&lt;/name&gt; &lt;age&gt;29&lt;/age&gt; &lt;/teacher&gt; &lt;teacher&gt; &lt;name&gt;lisi&lt;/name&gt; &lt;age&gt;29&lt;/age&gt; &lt;/teacher&gt; &lt;/teachers&gt; 名称空间的作用一个xml如果想指定它的约束规则， 假设使用的是DTD ，那么这个xml只能指定一个DTD ， 不能指定多个DTD 。 但是如果一个xml的约束是定义在schema里面，并且是多个schema，那么是可以的。简单的说： 一个xml 可以引用多个schema约束。 但是只能引用一个DTD约束。 名称空间的作用就是在 写元素的时候，可以指定该元素使用的是哪一套约束规则。 默认情况下 ，如果只有一套规则，那么都可以这么写 &lt;name&gt;张三&lt;/name&gt; &lt;aa:name&gt;&lt;/aa:name&gt; &lt;bb:name&gt;&lt;/bb:name&gt; 总结：xml 1. 会定义xml 2. 会解析xml dom4j 基本解析 Xpath手法]]></content>
      <categories>
        <category>安卓开发</category>
      </categories>
      <tags>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL]]></title>
    <url>%2F2019%2F01%2F25%2Fsql%2F</url>
    <content type="text"><![CDATA[SQL 完成对MYSQL数据库中数据库，表及数据的CURD操作目标掌握MYSQL的基本数据库，表及表中记录的操作1.完成对分类表的CURD的操作需求分析：使用CMD命令来创建一个数据库，并对数据库中的一张分类表进行增删改查操作； 数据库概述： 什么是数据库： 数据库就是一个文件系统，只不过我们需要通过命令(SQL)来操作这个文件系统 数据库(Database)是按照数据结构来组织、存储和管理数据的建立在计算机存储设备上的仓库。 数据库是长期存储在计算机内、有组织、可共享的数据集合。数据库中的数据指的是以一定的数据模型组织、描述和存储在一起、具有尽可能小的冗余度、较高的数据独立性和易拓展性的特点并可在一定范围内为多个用户共享。 数据库的作用： 储存数据，数据的仓库，带有访问权限限制不同人可以有不同的操作 为什么要学习数据库： 能持久化的存储数据，对数据的规模和类型有更好的管理。 操作的都是后台数据，取到后台数据进行封装，然后交给前端去展现 常见的数据库：mysql：开源免费的适用于中小型企业的免费数据库，sun公司收购了mysql，sun公司被oracle收购了，oracle收购之后，开始收费了 mariadb：由mysql创始人开发，是mysql开源版本的一个分支，基本上所有的命令与原来一致 oracle：甲骨文公司，商业软件，收费软件，适用于大型电商网站，收购lsun公司 db2：IBM公司，解决方案：软件和硬件，服务器架构，银行系统大多采用db2 sqlserver：windows里面，政府网站asp.net，并且大学教学通常都是采用SQLserver，图形化工具。 NOSQL非关系型数据库： key:valuemongodb redis 关系型数据库：主要是用来描述实体与实体之间的关系， 实实在在的事物：男生和女生 学生和班级 员工和部门 E-R关系图：要求必须掌握 实体：方框 属性：椭圆 关系：菱形 MYSQL数据库服务器MYSQL数据库：数据库管理软件 服务器：就是一台电脑，这台电脑安装相关的服务器软件，这些软件会监听不同的端口号，根据用户访问的端口号，提供不同的服务 MYSQL的SQL语句SQL：Structure Query Language 结构化查询语言 DDL：数据定义语言：定义数据库，数据表它们的结构： create drop alter DML：数据操纵语言：主要是用来操作数据 insert update delete DCL：数据控制语言：定义访问权限，取消访问权限，安全设置 grant DQL：数据查询语言： select from where 数据库的CURD的操作 首先要登录数据库服务器 创建数据库123456789create database 数据库的名字;create database test;-- 创建数据库的时候，指定字符集create database 数据库的名字 character set 字符集;create database test character set utf8;create database 数据库的名字 character set 字符集 collate 校对规则;create database test character set utf8 collate utf8_bin; 查看数据库123456-- 查看数据库定义的语句show create database 数据库名字;show create database test;-- 查看所有数据库show databases; 修改数据库的操作123-- 修改数据库的字符集alter database 数据库的名字 character set 字符集;alter database test character set gbk; 删除数据库12drop database 数据库名字;drop database test; 其他数据库操作命令123456-- 切换数据库(选中数据库)use 数据库名字;use test;-- 查看当前正在使用的数据库select database(); 表的CRUD操作创建表12345678910111213141516171819202122232425262728293031323334353637383940414243create database 数据库的名字;create table 表名( 列名 列的类型 约束, 列名2 列的类型 约束);列的类型;java sqlint intchar/string char/varchar char：固定长度 varchar：可变长度 长度代表的是字符的个数double doublefloat floatboolean booleandate date： YYYY-MM-DD datetime：YYYY-MM-DD hh:mm:ss 默认值是null timestamp：YYYY-MM-DD hh:mm:ss 默认使用当前时间 text：主要用来存放文本 blob：存放的是二进制 列的约束：主键约束：primary key唯一约束：unique非空约束：not null创建表：1.分析实体：学生2.学生ID3.姓名4.性别5.年龄create table student( sid int primary key, sname varchar(31), sex int, age int); 查看表12345678-- 查看所有的表show tables;-- 查看表的创建过程show create table student;-- 查看表的结构desc student; 修改表添加列(add)，修改列(modify)，修改列名(change)，删除列(drop)，修改表名(rename)，修改表的字符集 1234567891011121314151617-- 添加列(add)alter table 表名 add 列名 列的类型 列的约束alter table student add score int not null;-- 修改列(modify)alter table student modify sex varchar(2);-- 修改列名(change)alter table student change sex gender varchar(2);-- 下面两种比较少用-- 修改表名(rename)rename table student to s;-- 修改表的字符集alter table s character set gbk; 删除表1drop table s; Sql完成对表中数据的CRUD操作插入数据123456789101112131415161718192021222324insert into 表名(列名1,列名2,列名3) values(值1,值2,值3);insert into student(sid,sname,sex,age)valuse(1,&apos;zhangsan&apos;,1,23);-- 简单写法insert into student values(2,&apos;zhangsan&apos;,1,23);-- 注意：如果是插入部分的话，列名不能省略insert into student(sid,sname)values(3,&apos;lisi&apos;);insert into student values(3,&apos;lisi&apos;); //这种写法错误-- 批量插入insert into student values(4,&apos;zhangsan&apos;,1,23),(5,&apos;zhangsan&apos;,1,23),(6,&apos;zhangsan&apos;,1,23),(7,&apos;zhangsan&apos;,1,23),(8,&apos;zhangsan&apos;,1,23);-- 单条插入和批量插入的效率批量插入效率高，设计关键字少但是批量插入一条出错，全部都会受到影响。-- 查看表中数据select * from student; 命令行下插入中文的问题：insert into student values(11,’李四’,1,24); 临时解决方案：set name gbk; 相当于是告诉mysql服务器软件，我们当前在命令行下输入的内容是GBK编码，当命令窗口关闭之后，它再输入中文就会存在问题 永久解决办法：修改my.ini配置(在mysql软件的安装路径里) 暂停mysql的服务 在mysql安装路径中找到my.ini配置文件 将57(具体版本自行寻找)行的编码改成gbk 保存文件退出 启动mysql服务 删除记录 1234567891011delete from 表名 [where 条件]delete from student where sid=10;delete from student; //如果没有指定条件，会将表中数据一条一条的全部删除掉-- 面试问题：请说一下 delete 删除数据和 truncate 删除数据有什么区别delete：DML 一条一条删除表中数据truncate：DDL 先删除表再重建表关于哪条执行效率高：具体看表中的数据量如果数据比较少，delete比较高效如果是数据比较多，truncate比较高效 更新表记录1234567update 表名 set 列名=列的值,列名2=列的值2 [where 条件]-- 将sid为5的名字改成李四-- 如果参数是字符串，日期要加上单引号update student set sname=&apos;李四&apos; where sid=5;update student set sname=&apos;李四&apos;,sex=0; //全部改为 查询记录123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176select [distinct] [ * ] [列名,列名2] from 表名 [where 条件]distinct：去除重复的数据select：选择显示那些列的内容-- 商品分类：手机数码，鞋靴箱包1.分类的ID2。分类的名称3.分类的描述create table category( cid int primaty key auto_increment, cname varchar(10), cdesc varchar(31));insert into category values(null,&apos;手机数码&apos;,&apos;电子产品&apos;);insert into category values(null,&apos;鞋靴箱包&apos;,&apos;江南皮革厂打造&apos;);insert into category values(null,&apos;香烟酒水&apos;,&apos;中华,茅台,二锅头&apos;);insert into category values(null,&apos;酸奶饼干&apos;,&apos;哇哈哈,蒙牛酸酸乳&apos;);insert into category values(null,&apos;馋嘴零食&apos;,&apos;瓜子花生,八宝粥,辣条&apos;);select * from category;select canme,cdesc from category;-- 所有商品1.商品的ID2.商品的名称3.商品的价格4.生产日期5.商品分类ID商品和商品的分类：所属关系create table product( pid int primary key auto_increment, pname varchar(10), price double, pdate timestamp, cno int);insert into product values(null,&apos;小米mix4&apos;,998,null,1);insert into product values(null,&apos;锤子&apos;,2888,null,1);insert into product values(null,&apos;阿迪王&apos;,99,null,2);insert into product values(null,&apos;老村长&apos;,88,null,3);insert into product values(null,&apos;劲酒&apos;,35,null,3);insert into product values(null,&apos;小熊饼干&apos;,1,null,4);insert into product values(null,&apos;卫龙辣条&apos;,1,null,5);insert into product values(null,&apos;旺旺大饼&apos;,1,null,5);-- 简单查询-- 查询所有的商品select * from product;-- 查询商品名称和商品价格select panme,price from product;-- 别名查询，as的关键字，as关键字可以省略-- 表别名：select p.pname, p.price from product p;(主要用于多表查询)select p.pname,p.price from product as p;-- 列别名：select pname as 商品名称,price as 商品价格 from product;省略as关键字select pname 商品名称,price 商品价格 from product;-- 去掉重复的值-- 查询商品所有的价格select price from product;select distinct price from product;-- select运算查询：仅仅在查询结果上做运算 + - * /select *,price*1.5 from product;select *,price*1.5 as 折后价 from product;-- 条件查询[where关键字]指定条件，去顶要操作的记录-- 查询商品价格&gt;60元的所有商品信息select * from product where price &gt; 60;-- where后的条件写法-- 关系运算符：&gt; &gt;= &lt; &lt;= = != &lt;&gt;&lt;&gt;：不等于：标准SQL写法!=：不等于：非标准SQL写法-- 查询商品价格不等于88的所有商品select * from product where price &lt;&gt; 88;select * from product where price != 88;-- 查询商品价格在10到100之间select * from product where price &gt; 10 and peice &lt; 100;between ...and...select * from product where price between 10 and 100;-- 逻辑运算：and，or，not-- 查询出商品价格，小于35或者商品价格大于900select * from product where price &lt; 35 or price &gt; 900;-- like：模糊查询_：代表的是一个字符%：代表的是多个字符-- 查询出名字中带有饼的所有商品 &apos;%饼%&apos;select * from product where pname like &apos;%饼%&apos;;-- 查询第二个名字中是熊的所有商品select * from product where pname like &apos;_熊%&apos;；-- in在某个范围中获得值-- 查询出商品分类ID在 1，4，5里面的所有商品select * from product where cno in (1,4,5);-- 排序查询：order by 关键字asc：ascend 升序desc：descend 降序-- 0.查询所有商品，按价格进行排序select * from product order by price;-- 1.查询所有的商品，按价格进行降序排序(asc-升序 desc-降序);select * from peoduct order by price desc;-- 2.查询名称有 老 的商品，安价格降序排序1.查询名称有 小 的商品select * from product where pname like &apos;%小%&apos;;2.进行排序得出结果select * from product where pname like &apos;%小%&apos; order by price asc;--聚合函数：sum()：求和avg()：求平均值count()：统计数量max()：最大值min()：最小值-- 1.获得所有商品价格的总和：select sum(price) from product;-- 2.获得所有商品的平均价格：select avg(price) from product;-- 3.获得所有商品的个数：select count(*) from product;-- 注意:where 条件后面不能加聚合函数-- 查出商品价格大于平均价格的所有商品查出所有的商品select * from product;大于平均价格select avg(price) from product;-- 子查询select * from product where price &gt; (select avg(price) from product);-- 分组：group by-- 1.根据cno字段分组，分组后统计商品个数select cno,count(*) from product group by cno;-- 2.根据cno分组，分组统计每组商品的平均价格 并且商品平均价格 &gt; 60select cno,avg(price) from product group by cno having avg(price) &gt; 60;-- having 关键字 可以接聚合函数 出现在分组之后-- where 关键字 它是不可以接聚合函数 出现在分组之前-- 编写顺序-- S..F..W..G..H..Oselect .. from .. where .. group by .. having .. order by-- 执行顺序F..W..G..H..S..Ofrom .. where .. group by .. having .. select .. order by]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多表查询]]></title>
    <url>%2F2019%2F01%2F24%2Fmulti-table-queries%2F</url>
    <content type="text"><![CDATA[多表查询 任务完成对MYSQL数据库的多表查询及建表的操作目标掌握MYSQL中多表的创建及多表的查询掌握MYSQL中的表关系分析并能正确建表内容回顾: ​ 数据库的创建 : create database 数据库的名 character set 字符集 collate 校对规则 ​ 数据库的删除: drop database 数据库名 ​ 修改: alter database 数据库 character set 字符集(utf8) ​ 查询: show databases; ​ show create database 数据库的名字 ​ select database(); ​ 切换数据库 : ​ use 数据库的名字 ​ ​ 表结构的操作: ​ 创建: create table 表名( ​ 列名 列的类型 列的约束, ​ 列名 列的类型 列的约 ​ ) ​ 列的类型: char / varchar ​ 列的约束: ​ primary key 主键约束 ​ unique : 唯一约束 ​ not null 非空约束 ​ 自动增长 : auto_increment ​ 删除 : drop table 表名 ​ 修改: alter table 表名 (add, modify, change , drop) ​ rename table 旧表名 to 新表名 ​ alter table 表名 character set 字符集 ​ 查询表结构: ​ show tables; 查询出所有的表 ​ show create table 表名: 表的创建语句, 表的定义 ​ desc 表名: 表的结构 ​ 表中数据的操作 ​ 插入： insert into 表名(列名,列名) values(值1,值2); ​ 删除: delete from 表名 [where 条件] ​ 修改: update 表名 set 列名=’值’ ,列名=’值’ [where 条件]; ​ 查询: select [distinct] * [列名1,列名2] from 表名 [where 条件] ​ as关键字: 别名 ​ where条件后面: ​ ​ 关系运算符: &gt; &gt;= &lt; &lt;= != &lt;&gt; ​ –判断某一列是否为空: is null is not null ​ in 在某范围内 ​ between…and ​ 逻辑运算符: and or not ​ 模糊查询: like ​ _ : 代表单个字符 ​ %: 代表的是多个字符 ​ 分组: group by ​ 分组之后条件过滤: having ​ 聚合函数: sum() ,avg() , count() ,max(), min() ​ 排序: order by (asc 升序, desc 降序) ​ ​ ​ ​ ​ SQL 会创建多表及多表的关系需求:分类表和商品表之间是不是有关系? 如果有关系,在数据库中如何表示这种关系 123456789101112131415161718192021222324252627282930313233343536373839404142create table category( cid int primary key auto_increment, cname varchar(10), cdesc varchar(31));insert into category values(null,'手机数码','电子产品');insert into category values(null,'鞋靴箱包','江南皮鞋厂倾情打造');insert into category values(null,'香烟酒水','黄鹤楼,茅台,二锅头');insert into category values(null,'酸奶饼干','娃哈哈,蒙牛酸酸乳');insert into category values(null,'馋嘴零食','瓜子花生,八宝粥,辣条');select * from category;select cname,cdesc from category;--所有商品1.商品ID2.商品名称3.商品的价格4.生产日期5.商品分类ID商品和商品分类 : 所属关系create table product( pid int primary key auto_increment, pname varchar(10), price double, pdate timestamp, cno int);insert into product values(null,'小米mix4',998,null,1);insert into product values(null,'锤子',2888,null,1);insert into product values(null,'阿迪王',99,null,2);insert into product values(null,'老村长',88,null,3);insert into product values(null,'劲酒',35,null,3);insert into product values(null,'小熊饼干',1,null,4);insert into product values(null,'卫龙辣条',1,null,5);insert into product values(null,'旺旺大饼',1,null,5);//插入数据会失败insert into product values(null,'充气的气球',1,null,12); 技术分析: 多表之间的关系如何来维护 外键约束: foreign key 给product中的这个cno 添加一个外键约束 alter table product add foreign key(cno) references category(cid); 自己挖坑 从分类表中,删除分类为5信息, delete from category where cid =5; //删除失败 首先得去product表, 删除所有分类ID5 商品 建数据库原则: 通常情况下,一个项目/应用建一个数据库 多表之间的建表原则 一对多 : 商品和分类 建表原则: 在多的一方添加一个外键,指向一的一方的主键 ​ 多对多: 老师和学生, 学生和课程 建表原则: 建立一张中间表,将多对多的关系,拆分成一对多的关系,中间表至少要有两个外键,分别指向原来的那两张表 ​ 一对一: 班级和班长, 公民和身份证, 国家和国旗 建表原则: 将一对一的情况,当作是一对多情况处理,在任意一张表添加一个外键,并且这个外键要唯一,指向另外一张表 直接将两张表合并成一张表 将两张表的主键建立起连接,让两张表里面主键相等 实际用途: 用的不是很多. (拆表操作 ) 相亲网站: 个人信息 : 姓名,性别,年龄,身高,体重,三围,兴趣爱好,(年收入, 特长,学历, 职业, 择偶目标,要求) 拆表操作 : 将个人的常用信息和不常用信息,减少表的臃肿, ​ ​ 网上商城表实例的分析: 用户购物流程 ​ 用户表 (用户的ID,用户名,密码,手机) 12345678create table user( uid int primary key auto_increment, username varchar(31), password varchar(31), phone varchar(11));insert into user values(1,'zhangsan','123','13811118888'); 订单表 (订单编号,总价,订单时间 ,地址,外键用户的ID) 12345678910create table orders( oid int primary key auto_increment, sum int not null, otime timestamp, address varchar(100), uno int, foreign key(uno) references user(uid));insert into orders values(1,200,null,'前台旁边小黑屋',1);insert into orders values(2,250,null,'后台旁边小黑屋',1); 商品表 (商品ID, 商品名称,商品价格,外键cno) 12345678910111213141516create table product( pid int primary key auto_increment, pname varchar(10), price double, cno int, foreign key(cno) references category(cid));insert into product values(null,'小米mix4',998,1);insert into product values(null,'锤子',2888,1);insert into product values(null,'阿迪王',99,2);insert into product values(null,'老村长',88,3);insert into product values(null,'劲酒',35,3);insert into product values(null,'小熊饼干',1,4);insert into product values(null,'卫龙辣条',1,5);insert into product values(null,'旺旺大饼',1,5); ​ 订单项: 中间表(订单ID,商品ID,商品数量,订单项总价) 123456789101112131415create table orderitem( ono int, pno int, foreign key(ono) references orders(oid), foreign key(pno) references product(pid), ocount int, subsum double);--给1号订单添加商品 200块钱的商品insert into orderitem values(1,7,100,100);insert into orderitem values(1,8,101,100);--给2号订单添加商品 250块钱的商品 ()insert into orderitem values(2,5,1,35);insert into orderitem values(2,3,3,99); ​ ​ 商品分类表(分类ID,分类名称,分类描述) 1234567891011create table category( cid int primary key auto_increment, cname varchar(15), cdesc varchar(100));insert into category values(null,'手机数码','电子产品');insert into category values(null,'鞋靴箱包','江南皮鞋厂倾情打造');insert into category values(null,'香烟酒水','黄鹤楼,茅台,二锅头');insert into category values(null,'酸奶饼干','娃哈哈,蒙牛酸酸乳');insert into category values(null,'馋嘴零食','瓜子花生,八宝粥,辣条'); 多表之间的关系如何维护: 外键约束 : foreign key 添加一个外键: alter table product add foreign key(cno) references category(cid); ​ foreign key(cno) references category(cid) 删除的时候, 先删除外键关联的所有数据,再才能删除分类的数据 建表原则: 一对多: 建表原则: 在多的一方增加一个外键,指向一的一方 多对多: 建表原则: 将多对多转成一对多的关系,创建一张中间表 一对一: 不常用, 拆表操作 建表原则: 将两张表合并成一张表 将两张表的主键建立起关系 将一对一的关系当作一对多的关系去处理 主键约束: 默认就是不能为空, 唯一 外键都是指向另外一张表的主键 主键一张表只能有一个 唯一约束: 列面的内容, 必须是唯一, 不能出现重复情况, 为空 唯一约束不可以作为其它表的外键 可以有多个唯一约束 一对多 : 建表原则: 在多的一方添加一个外键,指向一的一方 多对多: 建表原则: ​ 拆成一对多 ​ 创建一张中间表, 至少要有两个外键, 指向原来的表 一对一: 建表原则: 合并一张表, 将主键建立关系 , 将它当作一对多的情况来处理 数据库客户端软件 ​ 使用商城表完成对商品信息的多表查询需求分析:在我们的商城案例中,我的订单中包含很多信息.打开我的订单需要去查询表 技术分析:多表查询 交叉连接查询 笛卡尔积 1select * from product,category; 内连接查询 123456789- 隐式内连接select * from product p,category c where p.cno=c.cid;- 显式内连接select * from product p inner join category c on p.cno=c.cid;- 区别：隐式内连接：在查询结果的基础上去做的where条件过滤显式内连接：带着条件去查询结果，执行效率要高 左外连接 1select * from product p left outer join category c on p.cno=c.cid; 右外连接 1select * from product p right outer join category c on p.cno=c.cid; 分页查询 每页数据数据3 起始索引从0 第1页: 0 第2页: 3 起始索引: index 代表显示第几页 页数从1开始 每页显示3条数据 startIndex = (index-1)*3 ​ 第一个参数是索引 第二个参数显示的个数 select * from product limit 0,3; select * from product limit 3,3; 子查询(了解的内容,非常重要)查询出(商品名称,商品分类名称)信息 12345- 左连接select * from product p left outer join category c on p. cno=c.cid;- 子查询select pname, (select * from category where p.cno=c.cid) as 商品分类名称 from product p; 查询分类名称为手机数码的所有商品 1select * from product where cno = (select cid from category where cname='手机数码'); 练习题 按照商品分类的名称统计商品的个数: 1 查询1号订单的订单项信息和商品信息 12 多表查询练习数据 员工信息表 123456789101112131415161718192021222324252627--员工信息表CREATE TABLE emp( empno INT, ename VARCHAR(50), job VARCHAR(50), mgr INT, hiredate DATE, sal DECIMAL(7,2), comm DECIMAL(7,2), deptno INT) ;INSERT INTO emp values(7369,'SMITH','CLERK',7902,'1980-12-17',800,NULL,20);INSERT INTO emp values(7499,'ALLEN','SALESMAN',7698,'1981-02-20',1600,300,30);INSERT INTO emp values(7521,'WARD','SALESMAN',7698,'1981-02-22',1250,500,30);INSERT INTO emp values(7566,'JONES','MANAGER',7839,'1981-04-02',2975,NULL,20);INSERT INTO emp values(7654,'MARTIN','SALESMAN',7698,'1981-09-28',1250,1400,30);INSERT INTO emp values(7698,'BLAKE','MANAGER',7839,'1981-05-01',2850,NULL,30);INSERT INTO emp values(7782,'CLARK','MANAGER',7839,'1981-06-09',2450,NULL,10);INSERT INTO emp values(7788,'SCOTT','ANALYST',7566,'1987-04-19',3000,NULL,20);INSERT INTO emp values(7839,'KING','PRESIDENT',NULL,'1981-11-17',5000,NULL,10);INSERT INTO emp values(7844,'TURNER','SALESMAN',7698,'1981-09-08',1500,0,30);INSERT INTO emp values(7876,'ADAMS','CLERK',7788,'1987-05-23',1100,NULL,20);INSERT INTO emp values(7900,'JAMES','CLERK',7698,'1981-12-03',950,NULL,30);INSERT INTO emp values(7902,'FORD','ANALYST',7566,'1981-12-03',3000,NULL,20);INSERT INTO emp values(7934,'MILLER','CLERK',7782,'1982-01-23',1300,NULL,10);INSERT INTO emp values(7981,'MILLER','CLERK',7788,'1992-01-23',2600,500,20); 部门信息表 12345678910CREATE TABLE dept( deptno INT, dname varchar(14), loc varchar(13));INSERT INTO dept values(10, 'ACCOUNTING', 'NEW YORK');INSERT INTO dept values(20, 'RESEARCH', 'DALLAS');INSERT INTO dept values(30, 'SALES', 'CHICAGO');INSERT INTO dept values(40, 'OPERATIONS', 'BOSTON'); 基本查询 12345678910111213--所有员工的信息--薪资大于等于1000并且小于等于2000的员工信息--从员工表中查询出所有的部门编号--查询出名字以A开头的员工的信息--查询出名字第二个字母是L的员工信息--查询出没有奖金的员工信息--所有员工的平均工资--所有员工的工资总和--所有员工的数量--最高工资--最少工资--最高工资的员工信息--最低工资的员工信息 分组查询 1--每个部门的平均工资 子查询 1234567891011121314151617181920212223-- 单行子查询(&gt; &lt; &gt;= &lt;= = &lt;&gt;) -- 查询出高于10号部门的平均工资的员工信息 -- 多行子查询(in not in any all) &gt;any &gt;all -- 查询出比10号部门任何员工薪资高的员工信息-- 多列子查询(实际使用较少) in -- 和10号部门同名同工作的员工信息-- Select接子查询 -- 获取员工的名字和部门的名字-- from后面接子查询 -- 查询emp表中经理信息-- where 接子查询 -- 薪资高于10号部门平均工资的所有员工信息-- having后面接子查询 -- 有哪些部门的平均工资高于30号部门的平均工资-- 工资&gt;JONES工资-- 查询与SCOTT同一个部门的员工-- 工资高于30号部门所有人的员工信息-- 查询工作和工资与MARTIN完全相同的员工信息-- 有两个以上直接下属的员工信息-- 查询员工编号为7788的员工名称,员工工资,部门名称,部门地址 SQL查询的综合案例 查询出高于本部门平均工资的员工信息 列出达拉斯加工作的人中,比纽约平均工资高的人 查询7369员工编号,姓名,经理编号和经理姓名 查询出各个部门薪水最高的员工所有信息 练习题1234567891011121314CREATE TABLE test( name CHAR(20), kecheng CHAR(20), fenshu CHAR(20));INSERT INTO test VALUES('张三','语文',81),('张三','数学',75),('李四','语文',76),('李四','数学',90),('王五','语文',81),('王五','数学',82);--请用一条Sql语句查处分数大于80的学生]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC]]></title>
    <url>%2F2019%2F01%2F22%2Fjdbc%2F</url>
    <content type="text"><![CDATA[JDBC JAVA Database Connectivity java 数据库连接 为什么会出现JDBC SUN公司提供的一种数据库访问规则、规范, 由于数据库种类较多，并且java语言使用比较广泛，sun公司就提供了一种规范，让其他的数据库提供商去实现底层的访问规则。 我们的java程序只要使用sun公司提供的jdbc驱动即可。 使用JDBC的基本步骤 注册驱动 DriverManager.registerDriver(new com.mysql.jdbc.Driver()); 建立连接 //DriverManager.getConnection(&quot;jdbc:mysql://localhost/test?user=monty&amp;password=greatsqldb&quot;); //2. 建立连接 参数一： 协议 + 访问的数据库 ， 参数二： 用户名 ， 参数三： 密码。 conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost/student&quot;, &quot;root&quot;, &quot;root&quot;); 创建statement //3. 创建statement ， 跟数据库打交道，一定需要这个对象 st = conn.createStatement(); 执行sql ，得到ResultSet //4. 执行查询 ， 得到结果集 String sql = &quot;select * from t_stu&quot;; rs = st.executeQuery(sql); 遍历结果集 //5. 遍历查询每一条记录 while(rs.next()){ int id = rs.getInt(&quot;id&quot;); String name = rs.getString(&quot;name&quot;); int age = rs.getInt(&quot;age&quot;); System.out.println(&quot;id=&quot;+id + &quot;===name=&quot;+name+&quot;==age=&quot;+age); } 释放资源 if (rs != null) { try { rs.close(); } catch (SQLException sqlEx) { } // ignore rs = null; } ... JDBC 工具类构建 资源释放工作的整合 驱动防二次注册 DriverManager.registerDriver(new com.mysql.jdbc.Driver()); Driver 这个类里面有静态代码块，一上来就执行了，所以等同于我们注册了两次驱动。 其实没这个必要的。 //静态代码块 ---&gt; 类加载了，就执行。 java.sql.DriverManager.registerDriver(new Driver()); 最后形成以下代码即可。 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); 使用properties配置文件 在src底下声明一个文件 xxx.properties ，里面的内容如下： driverClass=com.mysql.jdbc.Driver url=jdbc:mysql://localhost/student name=root password=root 在工具类里面，使用静态代码块，读取属性 static{ try { //1. 创建一个属性配置对象 Properties properties = new Properties(); InputStream is = new FileInputStream(&quot;jdbc.properties&quot;); //对应文件位于工程根目录 //使用类加载器，去读取src底下的资源文件。 后面在servlet //对应文件位于src目录底下 //InputStream is = JDBCUtil.class.getClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;); //导入输入流。 properties.load(is); //读取属性 driverClass = properties.getProperty(&quot;driverClass&quot;); url = properties.getProperty(&quot;url&quot;); name = properties.getProperty(&quot;name&quot;); password = properties.getProperty(&quot;password&quot;); } catch (Exception e) { e.printStackTrace(); } } ​ 数据库的CRUD sql insert 1INSERT INTO t_stu (NAME , age) VALUES (&apos;wangqiang&apos;,28) INSERT INTO t_stu VALUES (NULL,&apos;wangqiang2&apos;,28) // 1. 获取连接对象 conn = JDBCUtil.getConn(); // 2. 根据连接对象，得到statement st = conn.createStatement(); //3. 执行添加 String sql = &quot;insert into t_stu values(null , &apos;aobama&apos; , 59)&quot;; //影响的行数， ，如果大于0 表明操作成功。 否则失败 int result = st.executeUpdate(sql); if(result &gt;0 ){ System.out.println(&quot;添加成功&quot;); }else{ System.out.println(&quot;添加失败&quot;); } delete 1DELETE FROM t_stu WHERE id = 6 // 1. 获取连接对象 conn = JDBCUtil.getConn(); // 2. 根据连接对象，得到statement st = conn.createStatement(); //3. 执行添加 String sql = &quot;delete from t_stu where name=&apos;aobama&apos;&quot;; //影响的行数， ，如果大于0 表明操作成功。 否则失败 int result = st.executeUpdate(sql); if(result &gt;0 ){ System.out.println(&quot;删除成功&quot;); }else{ System.out.println(&quot;删除失败&quot;); } query 1SELECT * FROM t_stu // 1. 获取连接对象 conn = JDBCUtil.getConn(); // 2. 根据连接对象，得到statement st = conn.createStatement(); // 3. 执行sql语句，返回ResultSet String sql = &quot;select * from t_stu&quot;; rs = st.executeQuery(sql); // 4. 遍历结果集 while (rs.next()) { String name = rs.getString(&quot;name&quot;); int age = rs.getInt(&quot;age&quot;); System.out.println(name + &quot; &quot; + age); } update 1UPDATE t_stu SET age = 38 WHERE id = 1; // 1. 获取连接对象 conn = JDBCUtil.getConn(); // 2. 根据连接对象，得到statement st = conn.createStatement(); //3. 执行添加 String sql = &quot;update t_stu set age = 26 where name =&apos;qyq&apos;&quot;; //影响的行数， ，如果大于0 表明操作成功。 否则失败 int result = st.executeUpdate(sql); if(result &gt;0 ){ System.out.println(&quot;更新成功&quot;); }else{ System.out.println(&quot;更新失败&quot;); } 使用单元测试，测试代码 定义一个类， TestXXX , 里面定义方法 testXXX. 添加junit的支持。 右键工程 --- add Library --- Junit --- Junit4 在方法的上面加上注解 ， 其实就是一个标记。 @Test public void testQuery() { ... } 光标选中方法名字，然后右键执行单元测试。 或者是打开outline视图， 然后选择方法右键执行。 Dao模式 Data Access Object 数据访问对象 新建一个dao的接口， 里面声明数据库访问规则 /** * 定义操作数据库的方法 */ public interface UserDao { /** * 查询所有 */ void findAll(); } 新建一个dao的实现类，具体实现早前定义的规则 public class UserDaoImpl implements UserDao{ @Override public void findAll() { Connection conn = null; Statement st = null; ResultSet rs = null; try { //1. 获取连接对象 conn = JDBCUtil.getConn(); //2. 创建statement对象 st = conn.createStatement(); String sql = &quot;select * from t_user&quot;; rs = st.executeQuery(sql); while(rs.next()){ String userName = rs.getString(&quot;username&quot;); String password = rs.getString(&quot;password&quot;); System.out.println(userName+&quot;=&quot;+password); } } catch (Exception e) { e.printStackTrace(); }finally { JDBCUtil.release(conn, st, rs); } } } 直接使用实现 @Test public void testFindAll(){ UserDao dao = new UserDaoImpl(); dao.findAll(); } Statement安全问题 Statement执行 ，其实是拼接sql语句的。 先拼接sql语句，然后在一起执行。 String sql = &quot;select * from t_user where username=&apos;&quot;+ username +&quot;&apos; and password=&apos;&quot;+ password +&quot;&apos;&quot;; UserDao dao = new UserDaoImpl(); dao.login(&quot;admin&quot;, &quot;100234khsdf88&apos; or &apos;1=1&quot;); SELECT * FROM t_user WHERE username=&apos;admin&apos; AND PASSWORD=&apos;100234khsdf88&apos; or &apos;1=1&apos; 前面先拼接sql语句， 如果变量里面带有了 数据库的关键字，那么一并认为是关键字。 不认为是普通的字符串。 rs = st.executeQuery(sql); PrepareStatement 该对象就是替换前面的statement对象。 相比较以前的statement， 预先处理给定的sql语句，对其执行语法检查。 在sql语句里面使用 ? 占位符来替代后续要传递进来的变量。 后面进来的变量值，将会被看成是字符串，不会产生任何的关键字。 String sql = &quot;insert into t_user values(null , ? , ?)&quot;; ps = conn.prepareStatement(sql); //给占位符赋值 从左到右数过来，1 代表第一个问号， 永远你是1开始。 ps.setString(1, userName); ps.setString(2, password); ​ 总结： JDBC入门 抽取工具类 Statement CRUD 演练crud Dao模式 声明与实现分开 PrepareStament CRUD 预处理sql语句，解决上面statement出现的问题 小练习：1. dao里面声明 增删查改， 以及登录的方法 登录方法 ： 要求，成功后返回该用户的所有信息。 字段不限。 查询： 如果是findAll. 肯定是返回一个集合 List&lt;User&gt; 增加 &amp; 删除 &amp; 更新 返回影响的行数即可 int类型]]></content>
      <categories>
        <category>Java开发</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BootStrap]]></title>
    <url>%2F2019%2F01%2F22%2Fbootstrap%2F</url>
    <content type="text"><![CDATA[BootStrap 目标使用JQuery发送请求局部刷新页面使用BootStrap制作一个响应式的页面使用BootStrap制作网站的首页主要掌握掌握什么是响应式及响应式的原理掌握BootStrap的栅格系统了解BootStrap的其他组件及JS控件上次课内容: 什么JQ : write less do more 写更少的代码,做更多的事情 javascript函数库 基本选择器: ​ ID选择器: #ID名称 ​ 类选择器: .类名 ​ 元素选择器: 元素的名称 ​ 通配符选择器: * 找出页面上所有元素 ​ 选择器分组: 选择器1,选择器2 [选择器1 , 选择器2] 层级选择器: ​ 后代选择器: 选择器1 选择器2 找出来的选择器1 下面的所有选择器2 子孙 ​ 子元素选择器: 选择器1 &gt; 选择器2 找出来的是所有的子节点 儿子 ​ 相邻兄弟选择器: 选择器1+选择器2 找出来的紧挨着自己的弟弟 ​ 兄弟选择器: 选择器1~选择器2 找出所有的弟弟 ​ (找出所有兄弟: $(“div”).siblings() ) 属性选择器: 1234选择器 div选择器[title]选择器[title='test']选择器[title='test'][style] 基本的过滤器: 选择器:过滤器 $(“div:first”) ​ :first : 找出第一个元素 ​ :last 找出最后一个元素 ​ :even 找出偶数索引 ​ :odd 找出奇数 ​ :gt(index) greater-than大于 ​ :lt(index) 小于 ​ :eq(index) 等于 表单选择器: ​ :input 找出所有的输入项, textarea select button ​ :password ​ :text ​ :radio 表单对象属性的过滤器 ​ :selected ​ :checked 常用函数: ​ 属性prop() properties ​ 如果传入一个参数 就是获取 ​ prop(“src”,”../img/1.jpg”); ​ 设置图片路径 ​ attr : 操作一些自定义的属性 ​ prop: 通常是用来操作元素固有属性的 ,建议大家使用prop来操作属性 ​ css() ; 修改css样式 ​ addClass() : 添加一个class样式 ​ removeClass() : 移除 ​ ​ blur : 绑定失去焦点 ​ focus: 绑定获得焦点事件 ​ click: ​ dblclick ​ change ​ ​ append : 给自己添加儿子 ​ appendTo : 把自己添加到别人家 ​ prepend : 在自己子节点最前面添加子节点 ​ after : 在自己后面添加一个兄弟 ​ before: 在自己前面添加一个兄弟 ​ ​ $(“数组对象”).each(function(index,data)) ​ $.each(arr,function(index,data)) ​ 表单校验案例技术分析 trigger : 触发事件,但是会执行类似浏览将光标移到输入框内的这种浏览器默认行为 triggerHandler : 仅仅只会触发事件所对应的函数 is() 步骤分析 首先给必填项,添加尾部添加一个小红点 获取用户输入的信息,做相应的校验 事件: 获得焦点, 失去焦点, 按键抬起 表单提交的事件 代码实现12 使用JQuery发送请求局部刷新页面​ 数据交换格式: ​ json ​ xml ​ 什么是JSON JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。它基于ECMAScript的一个子集。 JSON采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯（包括C、C++、C#、Java、JavaScript、Perl、Python等）。这些特性使JSON成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成(一般用于提升网络传输速率)。 JSON格式 ​ JSON对象 12&#123; key1:value&#125; &#123;"username":"zhangsan","password":"123"&#125; ​ JSON数组 1[&#123; key1:value&#125;,&#123; key1:value&#125;,&#123; key1:value&#125;] ​ 使用BootStrap开发一个响应式的页面出来需求分析开发一套响应式页面.让他能够在各种设备上显示正常,提升用户体验 技术分析BootStap概述 什么是BootStrap ​ BootStrap有什么作用 复制粘贴, 能够提高开发人员的工作效率 什么是响应式页面 适应不同的分辨率显示不同样式,提高用户的体验 ​ BootStrap的中文网 http://www.bootcss.com 下载BootStrap BootStrap结构 全局CSS bootStrap中已经定义好了一套CSS的样式表 组件 BootStrap定义的一套按钮,导航条等组件 JS插件 BootStrap定义了一套JS的插件,这些插件已经默认实现了很多种效果 BootStrap的入门开发 引入相关的头文件 12345678910&lt;!-- 最新版本的 Bootstrap 核心 CSS 文件 --&gt;&lt;link rel="stylesheet" href="../css/bootstrap.css" /&gt;&lt;!--需要引入JQuery--&gt;&lt;script type="text/javascript" src="../js/jquery-1.11.0.js" &gt;&lt;/script&gt;&lt;!-- 最新的 Bootstrap 核心 JavaScript 文件 --&gt;&lt;script type="text/javascript" src="../js/bootstrap.js" &gt;&lt;/script&gt;&lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; BootStrap的布局容器 .container 类用于固定宽度并支持响应式布局的容器。 123&lt;div class=&quot;container&quot;&gt; ...&lt;/div&gt; .container-fluid 类用于 100% 宽度，占据全部视口（viewport）的容器。 123&lt;div class=&quot;container-fluid&quot;&gt; ...&lt;/div&gt; 校验表单扩展: trigger : 触发浏览器默认行为 triggerHandler : 不会触发 is : 判断 find : 查找 老黄历: 什么json: 轻量级的数据交换格式 json对象: {“username”:”zhangsan”} json数组: [ {“username”:”zhangsan”}, {“username”:”zhangsan”}, {“username”:”zhangsan”}] ajax异步请求: ​ 同步和异步 row Bootstrap 栅格系统的工作原理： “行（row）”必须包含在 .container （固定宽度）或 .container-fluid （100% 宽度）中，以便为其赋予合适的排列（aligment）和内补（padding）。 通过“行（row）”在水平方向创建一组“列（column）”。 你的内容应当放置于“列（column）”内，并且，只有“列（column）”可以作为行（row）”的直接子元素。 类似 .row 和 .col-xs-4 这种预定义的类，可以用来快速创建栅格布局。Bootstrap 源码中定义的 mixin 也可以用来创建语义化的布局。 通过为“列（column）”设置 padding 属性，从而创建列与列之间的间隔（gutter）。通过为 .row 元素设置负值 margin 从而抵消掉为 .container 元素设置的 padding，也就间接为“行（row）”所包含的“列（column）”抵消掉了padding ​ BootStrap的栅格系统 响应式设计: 这种设计依赖于CSS3中的媒体查询 栅格样式: 设备分辨率大于1200 使用lg样式 设备分辨率大于992 &lt; 1200 使用md样式 设备分辨率大于768 &lt; 992 使用sm样式 设备分辨率小于768使用xs样式 BootStrap的全局CSS 定义了一套CSS 对页面中的元素进行定义 列表元素,表单,按钮,图片… 步骤分析代码实现使用BootStrap布局网站首页需求分析请使用BootStrap对我们的首页进行优化 技术分析步骤分析 新建一个HTML页面.引入bootStrap相关的js和CSS 定义一个整体的div, 将整体的div分成8个部分 完成没部分的内容显示 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;!-- 准备工作: &lt;meta name='viewport'&gt; 1.导入bootstrap css文件 2.导入JQuery 3.bootstrap.js 4.写一个div class = container 支持响应式的布局容器 --&gt; &lt;link rel="stylesheet" href="../css/bootstrap.min.css"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;!-- jQuery文件。务必在bootstrap.min.js 之前引入 --&gt; &lt;script src="../js/jquery-1.11.0.js"&gt;&lt;/script&gt; &lt;!-- 最新的 Bootstrap 核心 JavaScript 文件 --&gt; &lt;script src="../js/bootstrap.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="container"&gt; &lt;div class="row"&gt; &lt;div class="col-md-4"&gt; &lt;img src="../img/logo2.png" /&gt; &lt;/div&gt; &lt;div class="col-md-4 hidden-xs"&gt; &lt;img src="../img/header.png" /&gt; &lt;/div&gt; &lt;div class="col-md-4"&gt; &lt;a href="#"&gt;登录&lt;/a&gt; &lt;a href="#"&gt;注册&lt;/a&gt; &lt;a href="#"&gt;购物车&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--菜单--&gt; &lt;div class="row"&gt; &lt;div class="col-md-12"&gt; &lt;nav class="navbar navbar-inverse" role="navigation"&gt; &lt;div class="container-fluid"&gt; &lt;!-- Brand and toggle get grouped for better mobile display --&gt; &lt;div class="navbar-header"&gt; &lt;button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1"&gt; &lt;span class="sr-only"&gt;Toggle navigation&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class="navbar-brand" href="#"&gt;首页&lt;/a&gt; &lt;/div&gt; &lt;!-- Collect the nav links, forms, and other content for toggling --&gt; &lt;div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1"&gt; &lt;ul class="nav navbar-nav"&gt; &lt;li class="active"&gt; &lt;a href="#"&gt;手机数码&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#"&gt;鞋靴箱包&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#"&gt;电脑办公&lt;/a&gt; &lt;/li&gt; &lt;li class="dropdown"&gt; &lt;a href="#" class="dropdown-toggle" data-toggle="dropdown"&gt;所有分类 &lt;span class="caret"&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class="dropdown-menu" role="menu"&gt; &lt;li&gt; &lt;a href="#"&gt;手机数码&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#"&gt;鞋靴箱包&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#"&gt;电脑办公&lt;/a&gt; &lt;/li&gt; &lt;li class="divider"&gt;&lt;/li&gt; &lt;li&gt; &lt;a href="#"&gt;Separated link&lt;/a&gt; &lt;/li&gt; &lt;li class="divider"&gt;&lt;/li&gt; &lt;li&gt; &lt;a href="#"&gt;One more separated link&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;form class="navbar-form navbar-right" role="search"&gt; &lt;div class="form-group"&gt; &lt;input type="text" class="form-control" placeholder="请输入要搜索的商品"&gt; &lt;/div&gt; &lt;button type="submit" class="btn btn-default"&gt;搜索&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;!-- /.navbar-collapse --&gt; &lt;/div&gt; &lt;!-- /.container-fluid --&gt; &lt;/nav&gt; &lt;/div&gt; &lt;/div&gt; &lt;div&gt; &lt;div id="carousel-example-generic" class="carousel slide" data-ride="carousel"&gt; &lt;!-- Indicators --&gt; &lt;ol class="carousel-indicators"&gt; &lt;li data-target="#carousel-example-generic" data-slide-to="0" class="active"&gt;&lt;/li&gt; &lt;li data-target="#carousel-example-generic" data-slide-to="1"&gt;&lt;/li&gt; &lt;li data-target="#carousel-example-generic" data-slide-to="2"&gt;&lt;/li&gt; &lt;/ol&gt; &lt;!-- Wrapper for slides --&gt; &lt;div class="carousel-inner" role="listbox"&gt; &lt;div class="item active"&gt; &lt;img src="../img/1.jpg" alt="..."&gt; &lt;div class="carousel-caption"&gt; ... &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;img src="../img/2.jpg" alt="..."&gt; &lt;div class="carousel-caption"&gt; ... &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;img src="../img/3.jpg" alt="..."&gt; &lt;div class="carousel-caption"&gt; ... &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- Controls --&gt; &lt;a class="left carousel-control" href="#carousel-example-generic" role="button" data-slide="prev"&gt; &lt;span class="glyphicon glyphicon-chevron-left"&gt;&lt;/span&gt; &lt;span class="sr-only"&gt;Previous&lt;/span&gt; &lt;/a&gt; &lt;a class="right carousel-control" href="#carousel-example-generic" role="button" data-slide="next"&gt; &lt;span class="glyphicon glyphicon-chevron-right"&gt;&lt;/span&gt; &lt;span class="sr-only"&gt;Next&lt;/span&gt; &lt;/a&gt;&lt;/div&gt; &lt;/div&gt; &lt;!--最新商品这里--&gt; &lt;div class="row"&gt; &lt;div class="col-md-12"&gt; &lt;h3&gt;最新商品&lt;img src="../images/title2.jpg"/&gt;&lt;/h3&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--商品部分 --&gt; &lt;div class="row"&gt; &lt;!--左边div--&gt; &lt;div class="col-md-2 hidden-sm hidden-xs"&gt; &lt;img src="../products/hao/big01.jpg" width="100%" height="100%" /&gt; &lt;/div&gt; &lt;!--右边div--&gt; &lt;div class="col-md-10"&gt; &lt;!--上面部分--&gt; &lt;div class="row"&gt; &lt;!--中等广告图--&gt; &lt;div class="col-md-6"&gt; &lt;img src="../products/hao/middle01.jpg" width="100%" /&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--下面部分--&gt; &lt;div class="row"&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="row"&gt; &lt;div class="col-md-12"&gt; &lt;img src="../products/hao/ad.jpg" width="100%" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--最新商品这里--&gt; &lt;div class="row"&gt; &lt;div class="col-md-12"&gt; &lt;h3&gt;最新商品&lt;img src="../images/title2.jpg"/&gt;&lt;/h3&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--商品部分 --&gt; &lt;div class="row"&gt; &lt;!--左边div--&gt; &lt;div class="col-md-2 hidden-sm hidden-xs"&gt; &lt;img src="../products/hao/big01.jpg" width="100%" height="100%" /&gt; &lt;/div&gt; &lt;!--右边div--&gt; &lt;div class="col-md-10"&gt; &lt;!--上面部分--&gt; &lt;div class="row"&gt; &lt;!--中等广告图--&gt; &lt;div class="col-md-6"&gt; &lt;img src="../products/hao/middle01.jpg" width="100%" /&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--下面部分--&gt; &lt;div class="row"&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--页脚广告--&gt; &lt;div&gt; &lt;img src="../image/footer.jpg" width="100%" /&gt; &lt;/div&gt; &lt;!--网站声明--&gt; &lt;div style="text-align: center;"&gt; &lt;a href="http://www.itheima.com"&gt;关于我们&lt;/a&gt; &lt;a href="http://www.itheima.com"&gt;联系我们&lt;/a&gt; &lt;a href="http://www.itheima.com"&gt;招贤纳士&lt;/a&gt; &lt;a href="http://www.itheima.com"&gt;法律声明&lt;/a&gt; &lt;a href="http://www.itheima.com"&gt;友情链接&lt;/a&gt; &lt;a href="http://www.itheima.com"&gt;支付方式&lt;/a&gt; &lt;a href="http://www.itheima.com"&gt;配送方式&lt;/a&gt; &lt;a href="http://www.itheima.com"&gt;服务声明&lt;/a&gt; &lt;a href="http://www.itheima.com"&gt;广告声明&lt;/a&gt; &lt;br /&gt; Copyright © 2005-2016 版权所有 &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 五天前端内容总结 JQ方式校验表单(要求做出来) json : (了解) json对象 {} json数组 [{},{}] $.get(url,function(data){}) (了解) bootstrap: Bootstrap 是最受欢迎的 HTML、CSS 和 JS 框架，用于开发响应式布局、移动设备优先的 WEB 项目。 全局CSS样式: css样式 栅格系统: 将屏幕划分成12个格子,12列 class=’row’ 当前是行 行里面放的是列 col-屏幕分辨率-数字 (每一种分辨率后的数字总和必须是等于12,如果超过12,另起一行) col-lg-数字: 在超宽屏幕上使用 col-md-数字: 在中等屏幕上,PC电脑 col-sm-数字: 在平板电脑上 col-xs-数字: 在手机上 组件: 导航条 , 进度条, 字体 javascript插件 : 轮播图 复制粘贴 什么是响应式: 会根据不同的分辨率去显示不同页面结构,提高用户体验 HTML: 超文本标记语言: 设计网页,决定了网页的结构 CSS: 层叠样式表 ,主要是用来美化页面, 将美化和HTML代码进行分离,提高代码复用性 javascript: 脚本语言,由浏览器解释执行, 弱类型语言(var i), 提供用户交互 jquery: javascript函数库,进一步的封装 选择器: ID选择器 类选择器 元素选择器 通配符选择器 选择器分组 层级选择器 后代选择器 子元素选择器 相邻兄弟选择器 兄弟选择器 : 找出所有的弟弟 属性选择器: 选择器[属性名称=’属性的值’] 表单选择器 :input :text :password body &gt; div &gt; div:nth-child(7) &gt; div:nth-child(3) &gt; div:nth-child(8) 基本的过滤器 :first :last :even :odd :gt :lt :eq 表单对象属性 :selected :checked]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>BootStrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JQuery]]></title>
    <url>%2F2019%2F01%2F22%2Fjquery%2F</url>
    <content type="text"><![CDATA[JQuery 目标使用JQuery完成页面定时弹出广告定时器: ​ setInterval clearInterval ​ setTimeout clearTimeout 显示: img.style.display = “block” 隐藏: img.style.display = “none” img 对象 ​ style属性: style对象 使用JQuery完成表格的隔行换色获得所有的行 ​ table.rows[] 修改行的颜色 ​ row.bgColor =”red” ​ row.style.backgroundColor = “black” ​ row.style.background = “red” ​ “background-color:red” ​ “background:red” 使用JQuery完成复选框的全选效果checked属性 如何获取所有复选框: ​ document.getElementsByName get Elements By Name 数据库里面 使用JQuery完成省市联动效果​ JS中的数组: [“城市”] ​ new Array() ​ DOM树操作: ​ 创建节点: document.createElement ​ 创建文本节点: document.createTextNode ​ 添加节点: appendChild 使用JQuery完成下列列表左右选择​ select下拉列表 ​ multiple 允许多选 ​ ondblclick : 双击事件 ​ for循环遍历,一边遍历一边移除出现的问题 使用JQuery完成表单的校验(扩展)​ 事件: ​ 获得焦点事件: onfocus ​ 失去焦点事件: onblur ​ 按键抬起事件: onkeyup ​ 鼠标移入: onmouseenter ​ 鼠标移出: onmouseout ​ JS引入外部文件 : script 今日目标：掌握JQuery的基本使用掌握JQuery的基本选择器,层次选择器会使用JQuery完成DOM的基本操作1. 使用JQuery完成页面定时弹出广告1.1 需求分析：当用户打开界面，3秒钟之后弹出广告，这个广告显示5秒钟，隐藏广告 1.2 技术分析定时器: setTimeout 显示和隐藏: style.display = “block/none” 什么JQuery: jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。jQuery设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优化HTML文档操作、事件处理、动画设计和Ajax交互。 jQuery的核心特性可以总结为：具有独特的链式语法和短小清晰的多功能接口；具有高效灵活的css选择器，并且可对CSS选择器进行扩展；拥有便捷的插件扩展机制和丰富的插件。jQuery兼容各种主流浏览器，如IE 6.0+、FF 1.5+、Safari 2.0+、Opera 9.0+等 JQuery的作用: ​ 1. 写更少的代码,做更多的事情: write Less ,Do more 2. 将我们页面的JS代码和HTML页面代码进行分离 为什么学习JQuery: ​ 提高我们的工作效率 JQ的入门 1234567891011121314151617181920212223242526272829&lt;script&gt; //js文档加载完成的事件 window.onload = function()&#123; alert("window.onload 111"); &#125; window.onload = function()&#123; alert("window.onload 222"); &#125; /*文档加载完成的事件*/ jQuery(document).ready(function()&#123; alert("jQuery(document).ready(function()"); &#125;); /* jQuery 简写成 $ */ $(document).ready(function()&#123; alert("$(document).ready(function()"); &#125;); /* 最简单的写法 */ $(function()&#123; alert("$(function()&#123;"); &#125;); &lt;/script&gt; 【JQ中根据ID查找元素】 1234全都是根据选择器去找的#ID&#123;&#125;.类名&#123;&#125;$("#ID的名称") 【JQ和JS之间的转换】 JQ对象,只能调用JQ的属性和方法 JS对象 只能调用JS的属性和方法 12345678910111213141516171819function changeJS()&#123; var div = document.getElementById("div1");// div.innerHTML = "JS成功修改了内容" //将JS对象转成JQ对象 $(div).html("转成JQ对象来修改内容") &#125; $(function()&#123; //给按钮绑定事件 $("#btn2").click(function()&#123; //找到div1// $("#div1").html("JQ方式成功修改了内容"); //将JQ对象转成JS对象来调用 var $div = $("#div1");// var jsDiv = $div.get(0); var jsDiv = $div[0]; jsDiv.innerHTML="jq转成JS对象成功"; &#125;); &#125;); JQ的开发步骤: (将我们页面的JS代码和HTML页面代码进行分离) 1. 导入JQ相关的文件 2. 文档加载完成事件: $(function) : 页面初始化的操作: 绑定事件, 启动页面定时器 3. 确定相关操作的事件 4. 事件触发函数 5. 函数里面再去操作相关的元素 显示和隐藏 img.style.display 【JQ中的动画效果】 1234567show()hide()slideUpslideDownfadeInfadeOutanimate : 自定义动画 1.3 步骤分析： 导入JQ的文件 编写JQ的文档加载事件 启动定时器 setTimeout(“”,3000); 编写显示广告的函数 在显示广告里面再启动一个定时器 编写隐藏广告的函数 1.4 代码实现1234567891011121314&lt;script&gt; //显示广告 function showAd()&#123; $("#img1").slideDown(2000); setTimeout("hideAd()",3000); &#125; //隐藏广告 function hideAd()&#123; $("#img1").slideUp(2000); &#125; $(function()&#123; setTimeout("showAd()",3000); &#125;); &lt;/script&gt; JQuery中的选择器让我们能够更加精确找到我们要操作的元素 基本选择器 ID选择器 : #ID的名称 类选择器: 以 . 开头 .类名 元素选择器: 标签的名称 通配符选择器: * 选择器,选择器: 选择器1,选择器2 基本选择器的案例12345678910111213141516171819202122232425262728293031323334&lt;!-- - ID选择器 : #ID的名称 - 类选择器: 以 . 开头 .类名 - 元素选择器: 标签的名称 - 通配符选择器: * - 选择器,选择器: 选择器1,选择器2 --&gt; &lt;script&gt; //文档加载事件,页面初始化的操作 $(function()&#123; //初始化操作: 给按钮绑定事件 $("#btn1").click(function()&#123; $("#two").css("background-color","palegreen"); &#125;); //找出mini类的所有元素 $("#btn2").click(function()&#123; $(".mini").css("background-color","palegreen"); &#125;); $("#btn3").click(function()&#123; $("div").css("background-color","palegreen"); &#125;); $("#btn4").click(function()&#123; $("*").css("background-color","palegreen"); &#125;); /*选择器分组*/ //找出mini类 和 span元素 $("#btn5").click(function()&#123; $(".mini,span").css("background-color","palegreen"); &#125;); &#125;); &lt;/script&gt; JQ中的层级选择器 子元素选择器: 选择器1 &gt; 选择器2 后代选择器: 选择器1 儿孙 相邻兄弟选择器 : 选择器1 + 选择器2 : 找出紧挨着的一个弟弟 找出所有弟弟: 选择器1~ 选择器2 : 找出所有的弟弟 123456789101112131415161718192021&lt;script&gt; //文档加载事件,页面初始化的操作 $(function()&#123; //初始化操作: 给按钮绑定事件 //找出body下面的子div $("#btn1").click(function()&#123; $("body &gt; div").css("background-color","palegreen"); &#125;); //找出body下面的所有div $("#btn2").click(function()&#123; $("body div").css("background-color","palegreen"); &#125;); $("#btn3").click(function()&#123; $("#one+div").css("background-color","palegreen"); &#125;); $("#btn4").click(function()&#123; $("#two~div").css("background-color","palegreen"); &#125;); &#125;); &lt;/script&gt; JQ中的基本过滤器12345678910111213141516171819202122232425&lt;script&gt; $(function()&#123; /&lt;script&gt; //文档加载事件,页面初始化的操作 $(function()&#123; //初始化操作: 给按钮绑定事件 //过滤出所有div中第一个元素 $("#btn1").click(function()&#123; $("div:first").css("background-color","palegreen"); &#125;); //过滤出所有div中偶数位的div $("#btn2").click(function()&#123; $("div:even").css("background-color","palegreen"); &#125;); $("#btn3").click(function()&#123; $("div:odd").css("background-color","palegreen"); &#125;); $("#btn4").click(function()&#123; $("div:gt(2)").css("background-color","palegreen"); &#125;); &#125;);&lt;/script&gt; JQ中的属性选择器123456789101112$(function()&#123; //找到有name属性的input $("#btn1").click(function()&#123; $("input[name]").attr("checked",true); &#125;); $("#btn2").click(function()&#123; $("input[name='accept']").attr("checked",true); &#125;); $("#btn3").click(function()&#123; $("input[name='newsletter'][value='Hot Fuzz']").attr("checked",true); &#125;); &#125;); JQ中的表单过滤器123456&lt;script&gt; //1.文档加载事件 $(function()&#123; $(":text").css("background-color","pink"); &#125;);&lt;/script&gt; 上午的内容回顾: 什么是JQ: write less , do more: 写更少的代码,做更多的事 ​ javascript函数库 1.11版本 定时器: 动画效果: ​ show : 显示 ​ hide : 隐藏 ​ slideDown: ​ slideUp: 向上滑动 ​ fadeIn ​ fadeOut JQ选择器: 基本选择器: ​ ID选择器: #ID的名字 ​ 类选择器: .类名 ​ 元素选择器: 标签名称 ​ 通配符选择器: * ​ 选择器分组: 选择器1,选择器2 层级选择器: ​ 后代选择器: 选择器1 儿孙 ​ 子元素选择器: 选择器1 &gt; 儿子 ​ 相邻兄弟选择器: 选择器1 + 选择器2 找出紧挨着它的弟弟 ​ 所有弟弟选择器: 选择器1~选择器2 找出所有弟弟 基本过滤器: ​ 选择器:first : 找出的是第一个 ​ :last ​ :even 找出索引为偶数 ​ :odd 找出奇数索引 ​ :gt(index) : 大于索引 ​ :lt(index) 小于 ​ :eq(index) 等于 属性选择器: ​ 选择器[href] : 单个属性 12选择器[href][title] : 多个属性选择器[href][title='test'] : 多个属性,包含值 表单过滤器: ​ :input 找出所有输入项: input textarea select ​ :text ​ :password 表单对象属性: ​ 找出select中被选中的那一项: ​ option:selected JQ的开发步骤: 1. 导入JQ相关的包 2. 文档加载文成的事件: 页面初始化: 绑定事件, 启动定时器 3. 确定事件 4. 实现事件索要触发的函数 5. 函数里面再去操作我们要操作的元素 使用JQ完成表格的隔行换色需求分析:在我们的实际开发过程中,我们的表格如果所有的行都是一样的话,很容易看花眼,所以我们需要让我们的表格隔行换色 技术分析:获取所有行 table.rows 遍历所有行 根据行号去修改每一行的背景颜色: bgColor ​ style.backgroundColor = “red” 步骤分析: 导入JQ的包 文档加载完成函数: 页面初始化 获得所有的行 : 元素选择器 根据行号去修改颜色 代码实现:123456789 $(function()&#123; //获得所有的行 : 元素选择器 $("tbody &gt; tr:even").css("background-color","#CCCCCC"); //修改基数行 $("tbody &gt; tr:odd").css("background-color","#FFF38F");// $("tbody &gt; tr").css("background-color","#FFF38F"); &#125;); 使用JQuery完成表单的全选全不选功能需求分析​ 在我们对表格处理的时,有些情况下,我们需要对表格进行批量处理, 技术分析:代码实现:使用JQ完成省市联动效果需求分析:​ 在我们的注册表单中,通常我们需要知道用户的籍贯,需要一个给用选择的项,当用户选中了省份之后,列出省下面所有的城市 技术分析: 准备工作 : 城市信息的数据 添加节点 : appendChild (JS) append : 添加子元素到末尾 appendTo : 给自己找一个爹,将自己添加到别人家里 prepend : 在子元素前面添加 after : 在自己的后面添加一个兄弟 遍历的操作: ​ 步骤分析: 导入JQ的文件 文档加载事件:页面初始化 进一步确定事件: change事件 函数: 得到当前选中省份 得到城市, 遍历城市数据 将遍历出来的城市添加到城市的select中 代码实现:123456789101112131415161718$(function()&#123; $("#province").change(function()&#123;// alert(this.value); //得到城市信息 var cities = provinces[this.value]; //清空城市select中的option /*var $city = $("#city"); //将JQ对象转成JS对象 var citySelect = $city.get(0) citySelect.options.length = 0;*/ $("#city").empty(); //采用JQ的方式清空 //遍历城市数据 $(cities).each(function(i,n)&#123; $("#city").append("&lt;option&gt;"+n+"&lt;/option&gt;"); &#125;); &#125;); &#125;); 使用JQ完成下拉列表左右选择需求分析我们的商品通常包含已经有了的, 还有没有的,现在我们需要有一个页面用于动态编辑这些商品 技术分析步骤分析1. 导入JQ的文件 2. 文档加载函数 :页面初始化 3.确定事件 : 点击事件 onclick 4. 事件触发函数 1. 移动被选中的那一项到右边 代码实现12345678910111213141516&lt;script type="text/javascript" src="../js/jquery-1.11.0.js" &gt;&lt;/script&gt;&lt;script&gt; $(function()&#123; $("#a1").click(function()&#123; //找到被选中的那一项 //将被选中项添加到右边 $("#rightSelect").append($("#leftSelect option:selected")); &#125;); //将左边所有商品移动到右边 $("#a2").click(function()&#123; $("#rightSelect").append($("#leftSelect option")); &#125;); &#125;);&lt;/script&gt; 今天内容总结:定时器 动画效果: show hide slideDown slideUp fadeIn fadeOut animate 基本选择器: ​ ID选择器: #ID名称 ​ 类选择器: .类名 ​ 元素选择器: 元素/标签名称 ​ 通配符选择器: * 找出所有页面元素 包含页面上所有的标签 ​ 选择器分组 : 选择器1, 选择器2 [选择器1,选择器2] 层级选择器: ​ 后代选择器: 选择器1 选择器2 找出所有的后代,儿子孙子曾孙 ​ 子元素选择器: 选择器1 &gt;选择器2 找出所有儿子 ​ 相邻兄弟选择器: 选择器1+选择器2 : 找出紧挨着自己那个弟弟 ​ 兄弟选择器 : 选择器1~选择器2 : 找出所有的弟弟 属性选择器: ​ 选择器[属性名称] 12选择器[属性名称][属性名名]选择器[属性名称='属性值'][属性名称='属性值'][属性名称='属性值'] 表单选择器: ​ :input 找出所有的输入项 : 不单单找出input textarea select ​ :text 找出type类型为 text ​ :password 基本过滤器: ​ :even ​ :odd ​ :gt ​ :lt ​ :eq ​ :first ​ :last 表单对象属性: ​ :selected ​ :checked 12345678910111213141516171819202122$(function) : 文档加载完成的事件css() : 修改css样式prop() : 修改属性/ 获取属性html() : 修改innerHTMLappend : 给自己添加子节点appendTo : 将自己添加到别人家,给自己找一个爹prepend : 在自己最前面添加子节点after : 在自己后面添加一个兄弟empty : 清空所有子节点$(cities).each(function(i,n)&#123; &#125;)$.each(arr,function(i,n)&#123; &#125;);了解, 熟悉, 熟练, 精通 经过一个项目,将所有学过串起来 使用JQ完成表单的校验(扩展)需求分析在用户提交表单的时候, 我们最好是能够在用户数据提交给服务器之前去做一次校验,防止服务器压力过大,并且需要给用户一个友好提示 技术分析 trigger triggerHandler is() 步骤分析 首先给必填项,添加尾部添加一个小红点 获取用户输入的信息,做相应的校验 事件: 获得焦点, 失去焦点, 按键抬起 表单提交的事件 代码实现]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>JQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript]]></title>
    <url>%2F2019%2F01%2F22%2Fjavascript%2F</url>
    <content type="text"><![CDATA[Javascript 使用JS完成页面定时弹出广告使用JS完成表单的校验使用JS完成表格的隔行换色使用JS完成复选框的全选效果使用JS完成省市的联动效果JS控制下拉列表左右选择教学导航 掌握JS中的BOM对象 掌握JS中的常用事件 掌握JS中的常用DOM操作 了解JS中的内置对象 上一次内容进行复习: CSS: 层叠样式表 主要作用: 美化页面, 将美化和HTML进行分离,提高代码复用性 选择器: ​ 元素选择器: 元素的名称{} ​ 类选择器: . 开头 ​ ID选择器: #ID选择器 ​ ​ 后代选择器: 选择器1 选择器2 ​ 子元素选择器: 选择器1 &gt; 选择器2 ​ 选择器分组: 选择器1,选择器2,选择器3{} ​ 属性选择器: 选择器[属性的名称=’属性的值’] ​ 伪类选择器: 浮动: ​ float 属性: left right 清除浮动: ​ clear 属性: both left right 盒子模型: 上右下左 padding 10px 20px 30px 40px 顺时针的方向 ​ 内边距: 控制的盒子内距离 ​ 边框: 盒子的边框 ​ 外边距: 控制盒子与盒子之间的距离 绝对定位: position : absolute; top: left JS开发: 是一门脚本语言,由浏览器来解释执行,不需要经过编译 JS声明变量: var 变量的名字; JS声明函数: function 函数的名称(参数的名字){} JS开发的步骤: 1. 确定事件 2. 事件要触发函数,所以我们是要声明函数 3. 函数里面通常是去做一些交互才操作, 弹框, 修改页面内容,动态去添加一些东西 0. 轮播图自动播放需求:有一组图片, 每隔3秒钟,就去切换一张,最终是一直在不停切换 技术分析:​ 切换图片: ​ 每个三秒钟做一件事: 步骤分析:1. 确定事件: 文档加载完成的事件 onload 2. 事件要触发 : init() 3. 函数里面要做一些事情:(通常会去操作元素,提供交互) 1. 开启定时器: 执行切换图片的函数 changeImg() 4. changeImg() 1. 获得要切换图片的那个元素 1. 完成页面定时弹出广告1.1 需求分析​ 一般网页，当我们刚打开的时候，它会5秒之后，显示一个广告，让我们看5秒钟，然后他的广告就自动消失了！ 1.2 技术分析 定时器 setInterval : 每隔多少毫秒执行一次函数 setTimeout: 多少毫秒之后执行一次函数 clearInterval clearTimeout 显示广告 img.style.display = “block” 隐藏广告 img.style.display = “none” 1.3 步骤分析 确定事件: 页面加载完成的事件 onload 事件要触发函数: init() init函数里面做一件事: 启动一个定时器 : setTimeout() 显示一个广告 再去开启一个定时5秒钟之后,关闭广告 1.4 代码实现1234567891011121314151617181920212223&lt;script&gt; function init()&#123; setTimeout("showAD()",3000); &#125; function showAD()&#123; //首先要获取要操作的img var img = document.getElementById("img1"); //显示广告 img.style.display = "block"; //再开启定时器,关闭广告 setTimeout("hideAD()",3000); &#125; function hideAD()&#123; //首先要获取要操作的img var img = document.getElementById("img1"); //隐藏广告 img.style.display = "none"; &#125; &lt;/script&gt; 1.5扩展 JS的引入方式 2. 完成完成表单的校验2.1 需求分析​ 昨天我们做了一个简单的表单校验，每当用户输入出错的时候，我们是弹出了一个对话框，提示用户去修改。这样的用户体验效果非常不好好。我们今天就是需要来对他进行一个修改，当用户输入信息有问题的时候，我们就再输入框的后面给他一个友好提示。 2.2 技术分析【HTML中innerHTML属性】 【JS中的常用事件】 onfocus 事件: 获得焦点事件 onblur : 失去焦点 onkeyup : 按键抬起事件 2.3 步骤分析2.4 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;!-- 引入外部的js文件 --&gt; &lt;script type="text/javascript" src="../js/regutils.js" &gt;&lt;/script&gt; &lt;script&gt; /* 1. 确定事件 : onfocus 2. 事件要驱动函数 3. 函数要干一些事情: 修改span的内容 */ function showTips(spanID,msg)&#123; //首先要获得要操作元素 span var span = document.getElementById(spanID); span.innerHTML = msg; &#125; /* 校验用户名: 1.事件: onblur 失去焦点 2.函数: checkUsername() 3.函数去显示校验结果 */ function checkUsername()&#123; //获取用户输入的内容 var uValue = document.getElementById("username").value; //对输入的内容进行校验 //获得要显示结果的span var span = document.getElementById("span_username"); if(uValue.length &lt; 6)&#123; //显示校验结果 span.innerHTML = "&lt;font color='red' size='2'&gt;对不起,太短&lt;/font&gt;"; return false; &#125;else&#123; span.innerHTML = "&lt;font color='red' size='2'&gt;恭喜您,可用&lt;/font&gt;"; return true; &#125; &#125; /* 密码校验 */ function checkPassword()&#123; //获取密码输入 var uPass = document.getElementById("password").value; var span = document.getElementById("span_password"); //对密码输入进行校验 if(uPass.length &lt; 6)&#123; span.innerHTML = "&lt;font color='red' size='2'&gt;对不起,太短&lt;/font&gt;"; return false; &#125;else&#123; span.innerHTML = "&lt;font color='red' size='2'&gt;恭喜您,够用&lt;/font&gt;"; return true; &#125; &#125; /* 确认密码校验 * */ function checkRePassword()&#123; //获取密码输入 var uPass = document.getElementById("password").value; //获取确认密码输入 var uRePass = document.getElementById("repassword").value; var span = document.getElementById("span_repassword"); //对密码输入进行校验 if(uPass != uRePass)&#123; span.innerHTML = "&lt;font color='red' size='2'&gt;对不起,两次密码不一致&lt;/font&gt;"; return false; &#125;else&#123; span.innerHTML = ""; return true; &#125; &#125; /* 校验邮箱 * */ function checkMail()&#123; var umail = document.getElementById("email").value; var flag = checkEmail(umail); var span = document.getElementById("span_email"); //对邮箱输入进行校验 if(flag)&#123; span.innerHTML = "&lt;font color='red' size='2'&gt;恭喜您,可用&lt;/font&gt;"; return true; &#125;else&#123; span.innerHTML = "&lt;font color='red' size='2'&gt;对不起,邮箱格式貌似有问题&lt;/font&gt;"; return false; &#125; &#125; function checkForm()&#123; var flag = checkUsername() &amp;&amp; checkPassword() &amp;&amp; checkRePassword() &amp;&amp; checkMail(); return flag; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form action="../01-自动轮播图片/图片自动轮播.html" onsubmit="return checkForm()" &gt; 用户名:&lt;input type="text" id="username" onfocus="showTips('span_username','用户名长度不能小于6')" onblur="checkUsername()" onkeyup="checkUsername()" /&gt;&lt;span id="span_username"&gt;&lt;/span&gt;&lt;br /&gt; 密码:&lt;input type="password" id="password" onfocus="showTips('span_password','密码长度不能小于6')" onblur="checkPassword()" onkeyup="checkPassword()"/&gt;&lt;span id="span_password"&gt;&lt;/span&gt;&lt;br /&gt; 确认密码:&lt;input type="password" id="repassword" onfocus="showTips('span_repassword','两次密码必须一致')" onblur="checkRePassword()" onkeyup="checkRePassword()" /&gt;&lt;span id="span_repassword"&gt;&lt;/span&gt;&lt;br /&gt; 邮箱:&lt;input type="text" id="email" onfocus="showTips('span_email','邮箱格式必须正确')" onblur="checkMail()" /&gt;&lt;span id="span_email"&gt;&lt;/span&gt;&lt;br /&gt; 手机号:&lt;input type="text" id="text" /&gt;&lt;br /&gt; &lt;input type="submit" value="提交" /&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 上午回顾:定时器: ​ setInterval(“test()”,3000) 每隔多少毫秒执行一次函数 ​ setTimeout(“test()”,3000) 多少毫秒之后执行一次函数 ​ timerID 上面定时器调用之后 ​ clearInterval() ​ clearTimeout() 切换图片 ​ img.src = “图片路径” 事件: 文档加载完成的事件 onload事件 显示广告 : img.style.display = “block” 隐藏广告: img.style.display =”none” 引入一个外部js文件 1&lt;script src="js文件的路径" type="text/javascript"/&gt; 表单校验中常用的事件: ​ 获得焦点事件: onfocus ​ 失去焦点事件 onblur ​ 按键抬起事件: onkeyup JS开发步骤 1. 确定事件 2. 事件要触发函数: 定义函数 3. 函数通常都要去做一些交互: 点击, 修改图片, 动态修改innerHTML属性... innerTEXT ​ 3.表格隔行换色3.1 需求分析​ 我们商品分类的信息太多，如果每一行都显示同一个颜色的话会让人看的眼花，为了提高用户体验，减少用户看错的情况，需要对表格进行隔行换色 3.2 技术分析改变行的颜色 3.3 步骤分析 确定事件: 文档加载完成 onload 事件要触发函数: init() 函数:操作页面的元素要操作表格中每一行 动态的修改行的背景颜色 3.4 代码实现1234567891011121314151617&lt;script &gt; function init()&#123; //得到表格 var tab = document.getElementById("tab"); //得到表格中每一行 var rows = tab.rows; //便利所有的行,然后根据奇数 偶数 for(var i=1; i &lt; rows.length; i++)&#123; var row = rows[i]; //得到其中的某一行 if(i%2==0)&#123; row.bgColor = "yellow"; &#125;else&#123; row.bgColor = "red" &#125; &#125; &#125;&lt;/script&gt; 4. 复选框的全选和全不选4.1 需求分析​ 商品分类界面中，当我们点击全选框的时候，我们希望选中所有的商品，当我们取消掉的时候，我们希望不选中所有的商品 4.2 技术分析​ 事件 : onclick点击事件 4.3 步骤分析全选和全不选步骤分析: 1.确定事件: onclick 单机事件2.事件触发函数: checkAll()3.函数要去做一些事情: 获得当前第一个checkbox的状态 获得所有分类项的checkbox 修改每一个checkbox的状态 代码实现123456789101112131415function checkAll()&#123;// 获得当前第一个checkbox的状态 var check1 = document.getElementById("check1"); //得到当前checked状态 var checked = check1.checked;// 获得所有分类项的checkbox// var checks = document.getElementsByTagName("input"); var checks = document.getElementsByName("checkone");// alert(checks.length); for(var i = 0; i &lt; checks.length; i++)&#123;// 修改每一个checkbox的状态 var checkone = checks[i]; checkone.checked = checked; &#125; &#125; 5. 省市联动效果5.1 需求分析5.2 技术分析什么是DOM: Document Object Model : 管理我们的文档 增删改查规则 【HTML中的DOM操作】 12345678910111213141516171819202122232425262728293031一些常用的 HTML DOM 方法： getElementById(id) - 获取带有指定 id 的节点（元素） appendChild(node) - 插入新的子节点（元素） removeChild(node) - 删除子节点（元素） 一些常用的 HTML DOM 属性： innerHTML - 节点（元素）的文本值 parentNode - 节点（元素）的父节点 childNodes - 节点（元素）的子节点 attributes - 节点（元素）的属性节点 查找节点：getElementById() 返回带有指定 ID 的元素。 getElementsByTagName() 返回包含带有指定标签名称的所有元素的节点列表（集合/节点数组）。 getElementsByClassName() 返回包含带有指定类名的所有元素的节点列表。 增加节点：createAttribute() 创建属性节点。 createElement() 创建元素节点。 createTextNode() 创建文本节点。 insertBefore() 在指定的子节点前面插入新的子节点。 appendChild() 把新的子节点添加到指定节点。 删除节点：removeChild() 删除子节点。 replaceChild() 替换子节点。 修改节点：setAttribute() 修改属性setAttributeNode() 修改属性节点 5.3 步骤分析5.4 代码实现12 6. 使用JS控制下拉列表左右选择6.1 需求分析:在我们的分类管理中,我们要能够去修改我们的分类信息,当我们一点修改的时候,跳转到一个可以编辑的页面,这里面能够修改分类的名称,分类的描述,以及分类的商品 6.2 步骤分析:6.3 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;!-- 步骤分析 1. 确定事件: 点击事件 :onclick事件 2. 事件要触发函数 selectOne 3. selectOne要做一些操作 (将左边选中的元素移动到右边的select中) 1. 获取左边Select中被选中的元素 2. 将选中的元素添加到右边的Select中就可以 --&gt; &lt;script&gt; function selectOne()&#123;// 1. 获取左边Select中被选中的元素 var leftSelect = document.getElementById("leftSelect"); var options = leftSelect.options; //找到右侧的Select var rightSelect = document.getElementById("rightSelect"); //遍历找出被选中的option for(var i=0; i &lt; options.length; i++)&#123; var option1 = options[i]; if(option1.selected)&#123; // 2. 将选中的元素添加到右边的Select中就可以 rightSelect.appendChild(option1); &#125; &#125; &#125; //将左边所有的商品移动到右边 function selectAll()&#123;// 1. 获取左边Select中被选中的元素 var leftSelect = document.getElementById("leftSelect"); var options = leftSelect.options; //找到右侧的Select var rightSelect = document.getElementById("rightSelect"); //遍历找出被选中的option for(var i=options.length - 1; i &gt;=0; i--)&#123; var option1 = options[i]; rightSelect.appendChild(option1); &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;table border="1px" width="400px"&gt; &lt;tr&gt; &lt;td&gt;分类名称&lt;/td&gt; &lt;td&gt;&lt;input type="text" value="手机数码"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;分类描述&lt;/td&gt; &lt;td&gt;&lt;input type="text" value="这里面都是手机数码"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;分类商品&lt;/td&gt; &lt;td&gt; &lt;!--左边--&gt; &lt;div style="float: left;"&gt; 已有商品&lt;br /&gt; &lt;select multiple="multiple" id="leftSelect" ondblclick="selectOne()"&gt; &lt;option&gt;华为&lt;/option&gt; &lt;option&gt;小米&lt;/option&gt; &lt;option&gt;锤子&lt;/option&gt; &lt;option&gt;oppo&lt;/option&gt; &lt;/select&gt; &lt;br /&gt; &lt;a href="#" onclick="selectOne()"&gt; &amp;gt;&amp;gt; &lt;/a&gt; &lt;br /&gt; &lt;a href="#" onclick="selectAll()"&gt; &amp;gt;&amp;gt;&amp;gt; &lt;/a&gt; &lt;/div&gt; &lt;!--右边--&gt; &lt;div style="float: right;"&gt; 未有商品&lt;br /&gt; &lt;select multiple="multiple" id="rightSelect"&gt; &lt;option&gt;苹果6&lt;/option&gt; &lt;option&gt;肾7&lt;/option&gt; &lt;option&gt;诺基亚&lt;/option&gt; &lt;option&gt;波导&lt;/option&gt; &lt;/select&gt; &lt;br /&gt; &lt;a href="#"&gt; &amp;lt;&amp;lt; &lt;/a&gt; &lt;br /&gt; &lt;a href="#"&gt; &amp;lt;&amp;lt;&amp;lt; &lt;/a&gt; &lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan="2"&gt; &lt;input type="submit" value="提交"/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt; 今天内容简单回顾: 定时器: ​ setInterval ​ setTimeout ​ clearInterval ​ clearTimeout 控制图片显示隐藏 ​ img.style.display = “block” ​ img.style.display = “none” 表单中常用的事件: ​ onfocus: 获取焦点事件 ​ onblur : 失去焦点的事件 ​ onkeyup: 按键抬起的事件 ​ onclick: 单击事件 ​ ondblclick: 双击事件 表格隔行换色,鼠标移入和移除要变色: ​ onmouseenter: 鼠标移入 ​ onmouseout: 鼠标移出 ​ onload: 文档加载完成事件 ​ onsubmit: 提交 ​ onchange: 下拉列表内容改变 checkbox.checked 选中状态 DOM的文档操作: ​ 添加节点: appendChild ​ 创建节点: document.createElement ​ 创建文本节点: document.createTextNode() JS开发步骤: 1. 确认事件 2. 事件触发函数 3. 函数里面要做一些交互 ​]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS&JS]]></title>
    <url>%2F2019%2F01%2F22%2Fcssandjs%2F</url>
    <content type="text"><![CDATA[CSS&amp;JS 使用CSS完成网站首页的优化使用CSS完成网站注册页面的优化使用JS完成简单的数据校验使用JS完成图片轮播效果目标： 了解CSS的概念 了解CSS的引入方式 了解CSS的基本用法和常用的选择器 了解CSS的盒子模型，悬浮和定位 了解JS的概念 掌握JS的基本语法，数据类型，能够使用JS完成简单的页面交互 去年的内容简单回顾 什么HTML : 超文本标记语言 p标签: 段落标签 br标签: 简单换行 h1-h6: 标题标签 hr标签: 水平分割线, 华丽的分割线 font标签: color属性改变颜色 , size b标签: 加粗 i标签: 斜体 strong标签: 带语义的加粗 em标签: 斜体标签,带语义 img标签: 图片标签 显示图片 ​ src: 指定图片路径(相对路径) ​ width: 宽度 ​ height: 高度 ​ alt: 图片加载失败时的提示 相对路径: ​ ./ 代表当前路径 ​ ../ 代表的是上一级路径 ​ ../../ 代表的是上上一级路径 ul标签: 无序列表 ol标签: 有序列表 li标签: 列表项 a标签: 超链接标签: ​ target: 打开方式 ​ href: 指定要跳转的链接地址 table标签: table &gt; tr &gt; td tr标签: 行 td标签: 列 ​ 合并行: rowspan ​ 合并列: colspan 网站注册案例: ​ form 标签: 表单标签,主要是用来向服务器提交数据 ​ method: 提交方式 get post ​ action : 提交的路径 ​ input 标签: ​ type: ​ password: 密码框 ​ text : 文本 ​ submit: 提交 ​ button: 普通的按钮 ​ reset: 重置按钮 ​ radio: 单选按钮 设置name属性让它们是一组 ​ checkbox: 复选按钮 ​ email: ​ date: ​ tel: frameset : 框架标签 ​ rows: ​ cols: frame: 使用CSS完成网站首页的优化需求分析:​ 由于我们昨天使用表格布局存在缺陷,那么我们要来考虑使用DIV+CSS来对页面进行优化 表格布局的缺陷: 1. 嵌套层级太多, 一旦出现嵌套顺序错乱, 整个页面达不到预期效果 2. 采用表格布局,页面不够灵活, 动其中某一块,整个表格布局的结构全都要变 技术分析HTML的块标签: ​ div标签: 默认占一行,自动换行 ​ span标签: 内容显示在同一行 CSS概述: ​ Cascading Style Sheets : 层叠样式表 ​ 红砖, 抹了一层水泥, 白灰 主要用作用: ​ 用来美化我们的HTML页面的 ​ HTML 决定网页的骨架 ,CSS 化妆 ​ 将页面的HTML和美化进行分离 CSS的简单语法: ​ 在一个style标签中,去编写CSS内容,最好将style标签写在这个head标签中 123456&lt;style&gt; 选择器&#123; 属性名称:属性的值; 属性名称2: 属性的值2; &#125;&lt;/style&gt; CSS选择器: 帮助我们找到我们要修饰的标签或者元素 元素选择: 1234元素的名称&#123; 属性名称:属性的值; 属性名称:属性的值;&#125; ID选择器: 12345以#号开头 ID在整个页面中必须是唯一的s#ID的名称&#123; 属性名称:属性的值; 属性名称:属性的值;&#125; 类选择器: 12345以 . 开头 .类的名称&#123; 属性名称:属性的值; 属性名称:属性的值;&#125; CSS的引入方式: ​ 外部样式: 通过link标签引入一个外部的css文件 ​ 内部样式: 直接在style标签内编写CSS代码 ​ 行内样式: 直接在标签中添加一个style属性, 编写CSS样式 CSS浮动 : 浮动的元素会脱离正常的文档流,在正常的文档流中不占空间 float属性: left right clear属性: 清除浮动 both : 两边都不允许浮动 left: 左边不允许浮动 right : 右边不允许浮动 流式布局 步骤分析: 创一个最外层div 第一部份: LOGO部分: 嵌套三个div 第二部分: 导航栏部分 : 放置5个超链接 第三部分: 轮播图 第四部分: 第五部分: 直接放一张图片 第六部分: 抄第四部分的 第七部分: 放置一张图片 第八部分: 放一堆超链接 代码实现:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .logo&#123; float: left; width: 33%; /*border-width: 1px; border-style: solid; border-color: red;*/ height: 60px; line-height: 60px; /* border: 1px solid red;*/ &#125; .amenu&#123; color: white; text-decoration: none; height: 50px; line-height: 50px; &#125; .product&#123; float: left; text-align: center; width: 16%; height: 240px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 1. 创一个最外层div 2. 第一部份: LOGO部分: 嵌套三个div 3. 第二部分: 导航栏部分 : 放置5个超链接 4. 第三部分: 轮播图 5. 第四部分: 6. 第五部分: 直接放一张图片 7. 第六部分: 抄第四部分的 8. 第七部分: 放置一张图片 9. 第八部分: 放一堆超链接 --&gt; &lt;div&gt; &lt;!--2. 第一部份: LOGO部分: 嵌套三个div--&gt; &lt;div&gt; &lt;div class="logo"&gt; &lt;img src="../img/logo2.png"/&gt; &lt;/div&gt; &lt;div class="logo"&gt; &lt;img src="../img/header.png"/&gt; &lt;/div&gt; &lt;div class="logo"&gt; &lt;a href="#"&gt;登录&lt;/a&gt; &lt;a href="#"&gt;注册&lt;/a&gt; &lt;a href="#"&gt;购物车&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--清除浮动--&gt; &lt;div style="clear: both;"&gt;&lt;/div&gt; &lt;!--3. 第二部分: 导航栏部分 : 放置5个超链接--&gt; &lt;div style="background-color: black; height: 50px;"&gt; &lt;a href="#" class="amenu"&gt;首页&lt;/a&gt; &lt;a href="#" class="amenu"&gt;手机数码&lt;/a&gt; &lt;a href="#" class="amenu"&gt;电脑办公&lt;/a&gt; &lt;a href="#" class="amenu"&gt;鞋靴箱包&lt;/a&gt; &lt;a href="#" class="amenu"&gt;香烟酒水&lt;/a&gt; &lt;/div&gt; &lt;!--4. 第三部分: 轮播图--&gt; &lt;div&gt; &lt;img src="../img/1.jpg" width="100%"/&gt; &lt;/div&gt; &lt;!--5. 第四部分:--&gt; &lt;div&gt; &lt;div&gt;&lt;h2&gt;最新商品&lt;img src="../img/title2.jpg"/&gt;&lt;/h2&gt;&lt;/div&gt; &lt;!--左侧广告图--&gt; &lt;div style="width: 15%; height: 480px; float: left;"&gt; &lt;img src="../products/hao/big01.jpg" width="100%" height="100%"/&gt; &lt;/div&gt; &lt;!-- 右侧商品 --&gt; &lt;div style="width: 84%; height: 480px;float: left;"&gt; &lt;div style="height: 240px; width: 50%; float: left;"&gt; &lt;img src="../products/hao/middle01.jpg" height="100%" width="100%" /&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--6. 第五部分: 直接放一张图片--&gt; &lt;div&gt; &lt;img src="../products/hao/ad.jpg" width="100%"/&gt; &lt;/div&gt; &lt;!--7. 第六部分: 抄第四部分的--&gt; &lt;div&gt; &lt;div&gt;&lt;h2&gt;最新商品&lt;img src="../img/title2.jpg"/&gt;&lt;/h2&gt;&lt;/div&gt; &lt;!--左侧广告图--&gt; &lt;div style="width: 15%; height: 480px; float: left;"&gt; &lt;img src="../products/hao/big01.jpg" width="100%" height="100%"/&gt; &lt;/div&gt; &lt;!-- 右侧商品 --&gt; &lt;div style="width: 84%; height: 480px;float: left;"&gt; &lt;div style="height: 240px; width: 50%; float: left;"&gt; &lt;img src="../products/hao/middle01.jpg" height="100%" width="100%" /&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--8. 第七部分: 放置一张图片--&gt; &lt;div&gt; &lt;img src="../img/footer.jpg" width="100%"/&gt; &lt;/div&gt; &lt;!--9. 第八部分: 放一堆超链接--&gt; &lt;div style="text-align: center;"&gt; &lt;a href="#"&gt;关于我们&lt;/a&gt; &lt;a href="#"&gt;联系我们&lt;/a&gt; &lt;a href="#"&gt;招贤纳士&lt;/a&gt; &lt;a href="#"&gt;法律声明&lt;/a&gt; &lt;a href="#"&gt;友情链接&lt;/a&gt; &lt;a href="#"&gt;支付方式&lt;/a&gt; &lt;a href="#"&gt;配送方式&lt;/a&gt; &lt;a href="#"&gt;服务声明&lt;/a&gt; &lt;a href="#"&gt;广告声明&lt;/a&gt; &lt;br /&gt; Copyright © 2005-2016 版权所有 &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 扩展: CSS的优先级 按照选择器搜索精确度来编写: 行内样式 &gt; ID选择器 &gt; 类选择器 &gt; 元素选择器 就近原则: 哪个离得近,就选用哪个的样式 CSS: 层叠样式表 主要作用: 1. 美化页面 2. 将页面美化和HTML代码进行分离,提高代码的服用型 选择器: 元素选择器: 标签的名称{} 类选择器: 以. 开头 .类的名称 ID选择器: 以#开头 , #ID的名称 (ID必须是页面上面唯一) CSS浮动: float : left, right 不再占有正常文档流中的空间 , 流式布局 clear : both left right ​ CSS中的其它选择器 选择器分组: 选择器1,选择器2{ 属性的名称:属性的值} 属性选择器: 1234a[title]a[titile='aaa']a[href][title]a[href][title='aaa'] 后代选择器: 爷爷选择器 孙子选择器 找出所有的后代 子元素选择器: 父选择器 &gt; 儿子选择器 伪类选择器: 通常都是用在A标签上 ​ ​ 使用DIV+CSS完成注册页面的优化需求分析由于我们的注册页面也是用table布局的,存在与首页同样的问题,所以我们需要使用div+css对我们的注册页面进行美化 总共是5部分内容 技术分析CSS的盒子模型: 万物皆盒子 内边距: padding-top: padding-right: padding-bottom: padding-left: 1234padding:10px; 上下左右都是10pxpadding:10px 20px; 上下是10px 左右是20pxpadding: 10px 20px 30px; 上 10px 右20px 下30px 左20pxpadding: 10px 20px 30px 40px; 上右下左, 顺时针的方向 外边距: margin-top: margin-right: margin-bottom: margin-left: CSS绝对定位: ​ position: absolute ​ top: 控制距离顶部的位置 ​ left: 控制距离左边的位置 步骤分析: 总共是5部分 第一部分是LOGO部分 第二部分是导航菜单 第三部分是注册部分 第四部分是FOOTER图片 第五部分是一堆超链接 代码实现:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="../css/main.css"/&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 1. 总共是5部分 2. 第一部分是LOGO部分 3. 第二部分是导航菜单 4. 第三部分是注册部分 5. 第四部分是FOOTER图片 6. 第五部分是一堆超链接 --&gt; &lt;div&gt; &lt;!--2. 第一部分是LOGO部分--&gt; &lt;div&gt; &lt;div class="logo"&gt; &lt;img src="../img/logo2.png" /&gt; &lt;/div&gt; &lt;div class="logo"&gt; &lt;img src="../img/header.png" /&gt; &lt;/div&gt; &lt;div class="logo"&gt; &lt;a href="#"&gt;登录&lt;/a&gt; &lt;a href="#"&gt;注册&lt;/a&gt; &lt;a href="#"&gt;购物车&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--清除浮动--&gt; &lt;div style="clear: both;"&gt;&lt;/div&gt; &lt;!--3. 第二部分是导航菜单--&gt; &lt;div style="background-color: black; height: 50px;"&gt; &lt;a href="#" class="amenu"&gt;首页&lt;/a&gt; &lt;a href="#" class="amenu"&gt;手机数码&lt;/a&gt; &lt;a href="#" class="amenu"&gt;电脑办公&lt;/a&gt; &lt;a href="#" class="amenu"&gt;鞋靴箱包&lt;/a&gt; &lt;a href="#" class="amenu"&gt;香烟酒水&lt;/a&gt; &lt;/div&gt; &lt;!--4. 第三部分是注册部分--&gt; &lt;div style="background: url(../image/regist_bg.jpg);height: 500px;"&gt; &lt;div style="position:absolute;top:200px;left:350px;border: 5px solid darkgray;width: 50%;height: 50%;background-color: white;"&gt; &lt;table width="60%" align="center"&gt; &lt;tr&gt; &lt;td colspan="2"&gt;&lt;font color="blue" size="6"&gt;会员注册&lt;/font&gt;USER REGISTER&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;用户名:&lt;/td&gt; &lt;td&gt;&lt;input type="text"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码:&lt;/td&gt; &lt;td&gt;&lt;input type="password"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;确认密码:&lt;/td&gt; &lt;td&gt;&lt;input type="password"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;email:&lt;/td&gt; &lt;td&gt;&lt;input type="email"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;姓名:&lt;/td&gt; &lt;td&gt;&lt;input type="text"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;性别:&lt;/td&gt; &lt;td&gt;&lt;input type="radio" name="sex"/&gt; 男 &lt;input type="radio" name="sex"/&gt; 女 &lt;input type="radio" name="sex"/&gt; 妖 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;出生日期:&lt;/td&gt; &lt;td&gt;&lt;input type="date"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;验证码:&lt;/td&gt; &lt;td&gt;&lt;input type="text"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;input type="submit" value="注册"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--5. 第四部分是FOOTER图片--&gt; &lt;div&gt; &lt;img src="../img/footer.jpg" width="100%"/&gt; &lt;/div&gt; &lt;!--9. 第四部分: 放一堆超链接--&gt; &lt;div style="text-align: center;"&gt; &lt;a href="#"&gt;关于我们&lt;/a&gt; &lt;a href="#"&gt;联系我们&lt;/a&gt; &lt;a href="#"&gt;招贤纳士&lt;/a&gt; &lt;a href="#"&gt;法律声明&lt;/a&gt; &lt;a href="#"&gt;友情链接&lt;/a&gt; &lt;a href="#"&gt;支付方式&lt;/a&gt; &lt;a href="#"&gt;配送方式&lt;/a&gt; &lt;a href="#"&gt;服务声明&lt;/a&gt; &lt;a href="#"&gt;广告声明&lt;/a&gt; &lt;br /&gt; Copyright © 2005-2016 版权所有 &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; CSS部分的回顾:​ CSS: 层叠样式表. ​ CSS作用: 美化页面,提高代码的复用性 ​ 选择器: ​ 需要掌握的: ​ 元素选择器: 标签的名称 ​ 类选择器: 以 . 开头 ​ ID选择器: 以#开头, #ID的名称 ID必须是唯一的 ​ 优先级: 按照选择精确度: 行内样式 &gt; ID选择器 &gt; 类选择器 &gt; 元素选择器 ​ 就近原则 ​ 扩展选择器: ​ 选择器分组: 选择器1,选择器2 以逗号隔开 ​ 后代选择器: 爷爷 孙子 中间以空格隔开 ​ 子元素选择器: 爸爸 &gt; 儿子 ​ 属性选择器: 选择器[属性的名称=’’] ​ 伪类选择器: 超链接标签上使用 ​ 浮动: float属性 left right ​ 清除浮动: clear: both left right ​ ​ 盒子模型: 顺时针 : 上右下左 ​ padding : 内边距 ,控制的是盒子内容的距离 ​ margin : 外边距 控制盒子与盒子之间的距离 ​ 绝对定位: ​ position: absolute ​ top: ​ left: 使用JS完成简单的数据校验需求分析使用JS完成对注册页面的简单数据校验,不允许出现用户名或密码为空的情况 技术分析JavaScript概述什么是javascript: JavaScript一种直译式脚本语言， 什么是脚本语言? ​ java源代码 —-&gt; 编译成.class文件 —–&gt; java虚拟机中才能执行 ​ 脚本语言: 源码 ——– &gt; 解释执行 ​ js由我们的浏览器来解释执行 HTML: 决定了页面的框架 CSS: 用来美化我们的页面 JS: 提供用户的交互的 JS的组成:ECMAScript : 核心部分 ,定义js的语法规范 DOM: document Object Model 文档对象模型 , 主要是用来管理页面的 BOM : Browser Object Model 浏览器对象模型, 前进,后退,页面刷新, 地址栏, 历史记录, 屏幕宽高 JS的语法:变量弱类型: var i = true 区分大小写 语句结束之后的分号 ,可以有,也可以没有 写在script标签 JS的数据类型: 基本类型 string number boolean undefine null 引用类型 对象, 内置对象 类型转换 js内部自动转换 JS的运算符和语句: 运算符和java 一样 “===” 全等号: 值和类型都必须相等 == 值相等就可以了 语句和java 一样 JS的输出 alert() 直接弹框 document.write() 向页面输出 console.log() 向控制台输出 innerHTML: 向页面输出 获取页面元素: document.getElementById(“id的名称”); JS声明变量: ​ var 变量的名称 = 变量的值 JS声明函数: ​ var 函数的名称 = function(){ ​ } ​ ​ function 函数的名称(){ ​ } JS的开发步骤1231. 确定事件2. 通常事件都会出发一个函数3. 函数里面通常都会去操作页面元素,做一些交互动作 步骤分析:代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; /* 1. 确认事件: 表单提交事件 onsubmit事件 2. 事件所要触发的函数: checkForm 3. 函数中要干点事情 1. 校验用户名, 用户不能为空, 长度不能小于6位 1.获取到用户输入的值 */ function checkForm()&#123; //获取用户名输入项 var inputObj = document.getElementById("username"); //获取输入项的值 var uValue = inputObj.value;// alert(uValue); //用户名长度不能6位 "" if(uValue.length &lt; 6 )&#123; alert("对不起,您的长度太短!"); return false; &#125; //密码长度大于6 和确认必须一致 //获取密码框输入的值 var input_password = document.getElementById("password"); var uPass = input_password.value; if(uPass.length &lt; 6)&#123; alert("对不起,您还是太短啦!"); return false; &#125; //获取确认密码框的值 var input_repassword = document.getElementById("repassword"); var uRePass = input_repassword.value; if(uPass != uRePass)&#123; alert("对不起,两次密码不一致!"); return false; &#125; //校验手机号 var input_mobile = document.getElementById("mobile"); var uMobile = input_mobile.value; // if(!/^[1][3578][0-9]&#123;9&#125;$/.test(uMobile))&#123; alert("对不起,您的手机号无法识别!"); return false; &#125; //校验邮箱: /^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+(\.[a-zA-Z0-9_-])+/ var inputEmail = document.getElementById("email"); var uEmail = inputEmail.value; if(!/^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+(\.[a-zA-Z0-9_-])+/.test(uEmail))&#123; alert("对不起,邮箱不合法"); return false; &#125; return true; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form action="JS开发步骤.html" onsubmit="return checkForm()"&gt; &lt;div&gt;用户名:&lt;input id="username" type="text" /&gt;&lt;/div&gt; &lt;div&gt;密码:&lt;input id="password" type="password" /&gt;&lt;/div&gt; &lt;div&gt;确认密码:&lt;input id="repassword" type="password" /&gt;&lt;/div&gt; &lt;div&gt;手机号码:&lt;input id="mobile" type="number" /&gt;&lt;/div&gt; &lt;div&gt;邮箱:&lt;input id="email" type="text" /&gt;&lt;/div&gt; &lt;div&gt;&lt;input type="submit" value="注册" /&gt;&lt;/div&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; javascript : 它是一门脚本语言 , 直接解释执行的语言 javascript: ​ ECMAScript : 定义的语法 ​ DOM: document Object Model ​ BOM: 浏览器对象模型 会定义变量: var 变量的名称 = 变量的值 会定义函数: ​ function 函数的名称(参数的名称){ ​ } 使用JS完成图片的轮播效果需求分析在我们的网站首页,通常需要有一块区域,用来显示广告,但是这块区域如果仅仅显示一张图片肯定是不够的, 故我们需要采用动态循环播放我们所有的广告. 技术分析:步骤分析:代码实现:1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; /* 当页面加载完成的时候, 动态切换图片 1.确定事件: 2.事件所要触发的函数 */ var index = 1; //切换图片的函数 function changeAd()&#123; //获取要操作的img var img = document.getElementById("imgAd"); img.src = "../img/"+(index%3+1)+".jpg"; //0,1,2 //1,2,3 index++; &#125; function init()&#123; //启动定时器 setInterval("changeAd()",3000); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body onload="init()"&gt; &lt;img src="../img/1.jpg" id="imgAd"/&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Welcome]]></title>
    <url>%2F2019%2F01%2F22%2Fbackgroudmusic%2F</url>
    <content type="text"><![CDATA[Tips：只显示1000首歌曲，歌单中有版权音乐，有些歌曲无法播放。]]></content>
      <categories>
        <category>日程</category>
      </categories>
      <tags>
        <tag>Schedule</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML]]></title>
    <url>%2F2019%2F01%2F22%2Fhtml%2F</url>
    <content type="text"><![CDATA[HTML 网站信息页面案例网站图片信息页面案例网站友情链接页面案例网站首页案例网站注册页面案例网站后台页面案例导航 了解什么是标记语言 了解HTML主要特性，主要变化以及发展趋势 了解HTML的结构标签 掌握HTML的主要标签（字体，图片，列表，链接，表单等标签） 1.网站信息页面1.1需求分析:公司需要一个对外宣传的网站介绍,介绍公司的主要业务,公司的发展历史,公司的口号等等信息 1.2技术分析:HTML概述:HTML: Hyper Text Markup Language 超文本标记语言 超文本: 比普通文本功能更加强大,可以添加各种样式 标记语言: 通过一组标签.来对内容进行描述. &lt;关键字&gt; , 是由浏览器来解释执行 123456&lt;h1&gt;静夜诗&lt;/h1&gt;&lt;b&gt;&lt;i&gt;--李白&lt;/i&gt; &lt;/b&gt; &lt;br/&gt;&lt;p&gt;床前明月光,&lt;/p&gt;&lt;p&gt;地上鞋两双,&lt;/p&gt;&lt;p&gt;举头望明月,&lt;/p&gt;&lt;p&gt;低头思故乡.&lt;/p&gt; 为什么要学习HTML:生活所迫 HTML的主要作用:设计网页的基础,HTML5 HTML语法规范&lt;!-- 1. 上面是一个文档声明 2. 根标签 html 3. html文件主要包含两部分. 头部分和体部分 头部分 : 主要是用来放置一些页面信息 体部分 : 主要来放置我们的HTML页面内容 4. 通过标签来对内容进行描述,标签通常都是由开始标签和结束标签组成 5. 标签不区分大小写, 官方建议使用小写 --&gt; 1.3步骤分析: 公司简介 需要标题 水平分割线 四个段落 第一个段落字体需要红色 1.4代码实现:1234567891011121314151617181920212223242526272829&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;网站信息页面&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 1. 公司简介 需要标题 2. 水平分割线 3. 四个段落 4. 第一个段落字体需要红色 --&gt; &lt;h3&gt;公司简介&lt;/h3&gt; &lt;hr /&gt; &lt;p&gt; &lt;font color="red"&gt;“程序员训练营”&lt;/font&gt;是由&lt;b&gt;&lt;i&gt;XXX&lt;/i&gt;&lt;/b&gt;联合中关村软件园、CSDN，并委托XXX进行教学实施的软件开发高端培训机构，致力于服务各大软件企业，解决当前软件开发技术飞速发展，而企业招不到优秀人才的困扰。 目前，“程序员训练营”已成长为行业“学员质量好、课程内容深、企业满意”的移动开发高端训练基地，并被评为中关村软件园重点扶持人才企业。 &lt;/p&gt; &lt;p&gt; &lt;strong&gt;程序员&lt;/strong&gt;的学员多为大学毕业后，&lt;em&gt;有理想、有梦想，&lt;/em&gt;想从事IT行业，而没有环境和机遇改变自己命运的年轻人。程序员的学员筛选制度，远比现在90%以上的企业招聘流程更为严格。任何一名学员想成功入学“程序员”，必须经历长达2个月的面试流程，这些流程中不仅包括严格的技术测试、自学能力测试，还包括性格测试、压力测试、品德测试等等测试。毫不夸张地说，程序员训练营所有学员都是精挑细选出来的。百里挑一的残酷筛选制度确保学员质量，并降低企业的用人风险。 &lt;/p&gt; &lt;p&gt; 程序员训练营不仅着重培养学员的基础理论知识，更注重培养项目实施管理能力，并密切关注技术革新，不断引入先进的技术，研发更新技术课程，确保学员进入企业后不仅能独立从事开发工作，更能给企业带来新的技术体系和理念。 &lt;/p&gt; &lt;p&gt; 一直以来，程序员以技术视角关注IT产业发展，以深度分享推进产业技术成长，致力于弘扬技术创新，倡导分享、 开放和协作，努力打造高质量的IT人才服务平台。 &lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 1.5 扩展内容​ b : 加粗 ​ i : 斜体 ​ strong: 加粗, 带语义标签 em: 斜体, 带语义 2.网站图片信息2.1需求分析:在网站中通常需要显示LOGO图片,显示效果如下 2.2技术分析img 标签: ​ 常用的属性; ​ width : 宽度 ​ height: 高度 ​ src : 指定文件路径 ​ alt: 图片加载失败时的提示内容 2.3步骤分析2.4代码实现12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 常用属性: src : 指定图片路径 width : 指定图片宽度 height : 图片高度 alt : 文件加载失败时的提示信息 --&gt; &lt;img src="../img/demo.jpg" width="500px" alt="这张图片可能加载问题" /&gt; &lt;/body&gt;&lt;/html&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!--在网页中显示图片--&gt; &lt;img src="../img/logo2.png" width="30%"/&gt; &lt;img src="../image/header.jpg" width="30%" /&gt; &lt;/body&gt;&lt;/html&gt; 2.5 扩展-文件路径 相对路径 123./ 代表的是当前路径../ 代表的上一级路径../../ 上上一级路径 3.网站友情链接页面3.1需求分析在网站中,通常会显示友商公司的网站链接 百度 新浪微博 程序员 3.2技术分析列表标签: ​ 无序列表: ul ​ type: 小圆圈,小圆点, 小方块 ​ 有序列表: ol ​ type: 1,a ,A,I, ​ start : 指定是起始索引 3.3步骤分析3.4代码实现12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;!-- 1.使用无序列表 百合网 世纪家园 珍爱网 非诚勿扰 --&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="http://www.baihe.com" target="_blank"&gt;百合网&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="http://www.jiayuan.com"&gt;世纪家园&lt;/a&gt;&lt;/li&gt; &lt;li&gt;珍爱网&lt;/li&gt; &lt;li&gt;非诚勿扰&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 3.5 扩展内容​ 点击链接,跳转去指定网站 ​ a 超链接标签 ​ 常用的属性: ​ href: 指定要跳转去的链接地址 ​ 如果是网络地址需要加上http协议 , ​ 如果访问的是本网站的html文件,可以直接写文件路径 ​ target : 以什么方式打开 ​ _self: 默认打开方式,在当前窗口打开 ​ _blank: 新起一个标签页打开页面 内容回顾: 网站信息案例 字体标签 font color: 颜色 size: 大小 1~7 face: 改变字体 p 段落标签 h标题标签 : 1~6 br 换行 hr 水平线 b 加粗 i 斜体 strong : 加粗 包含语义 em : 斜体 包含语义 网站图片案例 img标签 src : 指定图片的路径 width: 宽度 height: 高度 alt : 图片加载错误时的提示信息 相对路径: ./ 代表的是当前路径 ../ 代表的上一级路径 ../../ 代表的上上一级路径 友情链接: ul: 无序列表 type : ol: 有序列表 type : 样式 start : 起始索引 li : 列表项 a 超链接标签 href : 要访问的链接地址 target : 打开方式 网站首页 table标签 border: 指定边框 width : 宽度 height : 高度 bgcolor : 背景颜色 align : 对齐方式 tr标签 td标签 colspan: 跨列操作 rowspan: 跨行操作 表格单元格的合并 表格的嵌套 4.网站首页4.1需求分析:​ 根据产品文档,完成商城首页,显示效果如图: 4.2技术分析:表格标签table​ table标签: ​ 常用的属性: ​ bgcolor : 背景色 ​ width : 宽度 ​ height : 高度 ​ align : 对齐方式 ​ tr 标签 ​ td 标签 合并单元格:​ colspan : 跨列操作 ​ rowspan : 跨行操作 ​ 注意: 跨行或者跨列操作之后,被占掉的格子需要删除掉 表格的嵌套:​ 在td中可以嵌套一个表格 4.3步骤分析 创建一个8行一列的表格 第一部份: LOGO部分: 嵌套一个一行三列的表格 第二部分: 导航栏部分 : 放置5个超链接 第三部分: 轮播图 第四部分: 嵌套一个三行7列表格 第五部分: 直接放一张图片 第六部分: 抄第四部分的 第七部分: 放置一张图片 第八部分: 放一堆超链接 4.4代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 1. 创建一个8行一列的表格 2. 第一部份: LOGO部分: 嵌套一个一行三列的表格 3. 第二部分: 导航栏部分 : 放置5个超链接 4. 第三部分: 轮播图 5. 第四部分: 嵌套一个三行7列表格 6. 第五部分: 直接放一张图片 7. 第六部分: 抄第四部分的 8. 第七部分: 放置一张图片 9. 第八部分: 放一堆超链接 --&gt; &lt;table width="100%" &gt; &lt;!--第一部份: LOGO部分: 嵌套一个一行三列的表格--&gt; &lt;tr&gt; &lt;td&gt; &lt;table width="100%"&gt; &lt;tr&gt; &lt;td&gt; &lt;img src="../img/logo2.png" /&gt; &lt;/td&gt; &lt;td&gt; &lt;img src="../image/header.jpg" /&gt; &lt;/td&gt; &lt;td&gt; &lt;a href="#"&gt;登录&lt;/a&gt; &lt;a href="#"&gt;注册&lt;/a&gt; &lt;a href="#"&gt;购物车&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/td&gt; &lt;/tr&gt; &lt;!--第二部分: 导航栏部分 : 放置5个超链接--&gt; &lt;tr bgcolor="black"&gt; &lt;td height="50px"&gt; &lt;a href="#"&gt;&lt;font color="white"&gt;首页&lt;/font&gt;&lt;/a&gt; &lt;a href="#"&gt;&lt;font color="white"&gt;手机数码&lt;/font&gt;&lt;/a&gt; &lt;a href="#"&gt;&lt;font color="white"&gt;鞋靴箱包&lt;/font&gt;&lt;/a&gt; &lt;a href="#"&gt;&lt;font color="white"&gt;电脑办公&lt;/font&gt;&lt;/a&gt; &lt;a href="#"&gt;&lt;font color="white"&gt;香烟酒水&lt;/font&gt;&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;!--第三部分: 轮播图 --&gt; &lt;tr&gt; &lt;td&gt; &lt;img src="../img/1.jpg" width="100%" /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;!--第四部分: 嵌套一个三行7列表格--&gt; &lt;tr&gt; &lt;td&gt; &lt;table width="100%" height="500px"&gt; &lt;tr&gt; &lt;td colspan="7"&gt; &lt;h3&gt;最新商品&lt;img src="../img/title2.jpg"&gt;&lt;/h3&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr align="center"&gt; &lt;!--左边大图的--&gt; &lt;td rowspan="2" width="206px" height="480px"&gt; &lt;img src="../products/hao/big01.jpg" /&gt; &lt;/td&gt; &lt;td colspan="3" height="240px"&gt; &lt;img src="../products/hao/middle01.jpg" width="100%" height="100%" /&gt; &lt;/td&gt; &lt;td&gt; &lt;img src="../products/hao/small06.jpg" /&gt; &lt;p&gt;洗衣机&lt;/p&gt; &lt;p&gt;&lt;font color="red"&gt;$998&lt;/font&gt;&lt;/p&gt; &lt;/td&gt; &lt;td&gt; &lt;img src="../products/hao/small06.jpg" /&gt; &lt;p&gt;洗衣机&lt;/p&gt; &lt;p&gt;&lt;font color="red"&gt;$998&lt;/font&gt;&lt;/p&gt; &lt;/td&gt; &lt;td&gt; &lt;img src="../products/hao/small06.jpg" /&gt; &lt;p&gt;洗衣机&lt;/p&gt; &lt;p&gt;&lt;font color="red"&gt;$998&lt;/font&gt;&lt;/p&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr align="center"&gt; &lt;td&gt; &lt;img src="../products/hao/small06.jpg" /&gt; &lt;p&gt;洗衣机&lt;/p&gt; &lt;p&gt;&lt;font color="red"&gt;$998&lt;/font&gt;&lt;/p&gt; &lt;/td&gt; &lt;td&gt; &lt;img src="../products/hao/small06.jpg" /&gt; &lt;p&gt;洗衣机&lt;/p&gt; &lt;p&gt;&lt;font color="red"&gt;$998&lt;/font&gt;&lt;/p&gt; &lt;/td&gt; &lt;td&gt; &lt;img src="../products/hao/small06.jpg" /&gt; &lt;p&gt;洗衣机&lt;/p&gt; &lt;p&gt;&lt;font color="red"&gt;$998&lt;/font&gt;&lt;/p&gt; &lt;/td&gt; &lt;td&gt; &lt;img src="../products/hao/small06.jpg" /&gt; &lt;p&gt;洗衣机&lt;/p&gt; &lt;p&gt;&lt;font color="red"&gt;$998&lt;/font&gt;&lt;/p&gt; &lt;/td&gt; &lt;td&gt; &lt;img src="../products/hao/small06.jpg" /&gt; &lt;p&gt;洗衣机&lt;/p&gt; &lt;p&gt;&lt;font color="red"&gt;$998&lt;/font&gt;&lt;/p&gt; &lt;/td&gt; &lt;td&gt; &lt;img src="../products/hao/small06.jpg" /&gt; &lt;p&gt;洗衣机&lt;/p&gt; &lt;p&gt;&lt;font color="red"&gt;$998&lt;/font&gt;&lt;/p&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/td&gt; &lt;/tr&gt; &lt;!--第五部分: 直接放一张图片--&gt; &lt;tr&gt; &lt;td&gt; &lt;img src="../products/hao/ad.jpg" width="100%" /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;!--第六部分: 抄第四部分的--&gt; &lt;tr&gt; &lt;td&gt; &lt;table width="100%" height="500px"&gt; &lt;tr&gt; &lt;td colspan="7"&gt; &lt;h3&gt;热门商品&lt;img src="../img/title2.jpg"&gt;&lt;/h3&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr align="center"&gt; &lt;!--左边大图的--&gt; &lt;td rowspan="2" width="206px" height="480px"&gt; &lt;img src="../products/hao/big01.jpg" /&gt; &lt;/td&gt; &lt;td colspan="3" height="240px"&gt; &lt;img src="../products/hao/middle01.jpg" width="100%" height="100%" /&gt; &lt;/td&gt; &lt;td&gt; &lt;img src="../products/hao/small06.jpg" /&gt; &lt;p&gt;洗衣机&lt;/p&gt; &lt;p&gt;&lt;font color="red"&gt;$998&lt;/font&gt;&lt;/p&gt; &lt;/td&gt; &lt;td&gt; &lt;img src="../products/hao/small06.jpg" /&gt; &lt;p&gt;洗衣机&lt;/p&gt; &lt;p&gt;&lt;font color="red"&gt;$998&lt;/font&gt;&lt;/p&gt; &lt;/td&gt; &lt;td&gt; &lt;img src="../products/hao/small06.jpg" /&gt; &lt;p&gt;洗衣机&lt;/p&gt; &lt;p&gt;&lt;font color="red"&gt;$998&lt;/font&gt;&lt;/p&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr align="center"&gt; &lt;td&gt; &lt;img src="../products/hao/small06.jpg" /&gt; &lt;p&gt;洗衣机&lt;/p&gt; &lt;p&gt;&lt;font color="red"&gt;$998&lt;/font&gt;&lt;/p&gt; &lt;/td&gt; &lt;td&gt; &lt;img src="../products/hao/small06.jpg" /&gt; &lt;p&gt;洗衣机&lt;/p&gt; &lt;p&gt;&lt;font color="red"&gt;$998&lt;/font&gt;&lt;/p&gt; &lt;/td&gt; &lt;td&gt; &lt;img src="../products/hao/small06.jpg" /&gt; &lt;p&gt;洗衣机&lt;/p&gt; &lt;p&gt;&lt;font color="red"&gt;$998&lt;/font&gt;&lt;/p&gt; &lt;/td&gt; &lt;td&gt; &lt;img src="../products/hao/small06.jpg" /&gt; &lt;p&gt;洗衣机&lt;/p&gt; &lt;p&gt;&lt;font color="red"&gt;$998&lt;/font&gt;&lt;/p&gt; &lt;/td&gt; &lt;td&gt; &lt;img src="../products/hao/small06.jpg" /&gt; &lt;p&gt;洗衣机&lt;/p&gt; &lt;p&gt;&lt;font color="red"&gt;$998&lt;/font&gt;&lt;/p&gt; &lt;/td&gt; &lt;td&gt; &lt;img src="../products/hao/small06.jpg" /&gt; &lt;p&gt;洗衣机&lt;/p&gt; &lt;p&gt;&lt;font color="red"&gt;$998&lt;/font&gt;&lt;/p&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第七部分: 放置一张图片--&gt; &lt;tr&gt; &lt;td&gt; &lt;img src="../image/footer.jpg" width="100%" /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;!--第八部分: 放一堆超链接--&gt; &lt;tr&gt; &lt;td align="center"&gt; &lt;a href="#"&gt;关于我们&lt;/a&gt; &lt;a href="#"&gt;联系我们&lt;/a&gt; &lt;a href="#"&gt;招贤纳士&lt;/a&gt; &lt;a href="#"&gt;法律声明&lt;/a&gt; &lt;a href="#"&gt;友情链接&lt;/a&gt; &lt;a href="#"&gt;支付方式&lt;/a&gt; &lt;a href="#"&gt;配送方式&lt;/a&gt; &lt;a href="#"&gt;服务声明&lt;/a&gt; &lt;a href="#"&gt;广告声明&lt;/a&gt; &lt;br /&gt;Copyright © 2005-2016 版权所有 &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt; 5.网站注册页面:5.1需求分析:​ 编写一个HTML页面, 显示效果如图所示 5.2技术分析: 表单标签 123456789101112131415161718192021222324252627282930313233343536&lt;!-- 表单标签 action : 直接提交的地址 method : get 方式 默认提交方式 ,会将参数拼接在链接后面 , 有大小限制 ,4k post 方式 会将参数封装在请求体中, 没有这样的限制 input : type: 指定输入项的类型 text : 文本 password : 密码框 radio : 单选按钮 checkbox : 复选框 file : 上传文件 submit : 提交按钮 button : 普通按钮 reset : 重置按钮 hidden : 隐藏域 date : 日期类型 tel : 手机号 number : 只允许输入数字 placeholder : 指定默认的提示信息 name : 在表单提交的时候,当作参数的名称 id : 给输入项取一个名字, 以便于后期我们去找到它,并且操作它 textarea : 文本域, 可以输入一段文本 cols : 指定宽度 rows : 指定的是高度 select : 下拉列表 option : 选择项 --&gt; ​ 步骤分析: logo部分 导航栏 注册部分 页脚图片 网站声明信息 5.3代码实现:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;form action="注册入门案例.html"&gt; &lt;table width="60%" align="center"&gt; &lt;tr&gt; &lt;td colspan="2"&gt;&lt;font color="blue" size="5"&gt;会员注册&lt;/font&gt; USER REGISTER&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;用户名:&lt;/td&gt; &lt;td&gt; &lt;input type="text" placeholder="请输入用户名"/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密 码:&lt;/td&gt; &lt;td&gt; &lt;input type="password" placeholder="请输入密码"/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;确认密码:&lt;/td&gt; &lt;td&gt; &lt;input type="password" placeholder="请再次输入密码"/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;email:&lt;/td&gt; &lt;td&gt; &lt;input type="text" placeholder="请输入邮箱"/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;姓名:&lt;/td&gt; &lt;td&gt; &lt;input type="text" placeholder="请输入真实姓名"/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;性别:&lt;/td&gt; &lt;td&gt; &lt;input type="radio" name="sex" /&gt; 男 &lt;input type="radio" name="sex" /&gt; 女 &lt;input type="radio" name="sex" /&gt; 妖 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;出生日期:&lt;/td&gt; &lt;td&gt; &lt;input type="date" /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;验证码:&lt;/td&gt; &lt;td&gt; &lt;input type="text" /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt; &lt;input type="submit" value="注册" /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/form&gt; 6.网站后台页面展示6.1需求分析:我们前面已经做完了首页商品展示, 那么我们需要一个页面用来编辑我们的商品信息, 还有商品分类, 用户购买之后,还得有订单管理页面 6.2技术分析框架标签:frameset 注意: 使用了frameset必须将body删掉,否则页面会有问题 frame 常用属性: ​ src: 引入的html文件路径​ name: 指定框架的名称 6.3步骤分析6.4代码实现扩展框架中点击跳转 常用的快捷键123456Ctrl + D 删除光标当前所在的行Ctrl + Shift + R 复制当前行到下一行Ctrl + Enter 将光标移动到下一行Ctrl + Shift + Enter 将光标定位在上一行Ctrl + Shift + / 注释当前行Ctrl + R 运行当前网页/刷新当前网页]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github 搭建 Hexo 博客]]></title>
    <url>%2F2019%2F01%2F16%2Fhexo%2F</url>
    <content type="text"><![CDATA[Github 搭建 Hexo 博客 简介本篇文章主要讲解Hexo在GitHub上搭建博客接下来让我们一起进入Hexo搭建博客学习吧。 Hexo什么是Hexo？Hexo是一个快速、简洁且高效的博客框架。Hexo使用Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 当我们在遇到一个新东西的时候，进入其官网能帮助我们解决很多问题。关于什么是Hexo？还有一些关于Hexo的问题，大家进入Hexo官网进行查看。 如何使用我们在使用Hexo之前需要准备一些东西，也就是需要安装一些我们必需的。 安装安装所需安装Hexo相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序： Node.js Git npm 如果npm运行出错就安装cnpm国内镜像 如果没有安装那么就需要安装咯，大家可以看看Vue-cli项目创建如何检查Node.js、Git和cnpm是否安装成功。 安装Hexo所有必备的应用程序安装完成后，即可使用npm或者cnpm来安装Hexo。打开Git Bash Here输入： 1npm install -g hexo-cli 检查是否安装Hexo完成,查询是否成功，显示hexo-cli版本就说明成功了 1hexo -V 建站安装一切所需的程序后，我们可以开始建站了，就是创建我们的博客,大家也可以进入Hexo建站官网查看。新建一个文件夹，来管理我们的博客项目，请执行下列命令，Hexo将会在指定文件夹中新建所需要的文件。 运行命令123hexo init &lt;folder&gt;cd &lt;folder&gt;npm install 注：folder是表示建站的博客项目名 打开Git Bash Here，输入： 1hexo init myblog 再运行以下命令：myblog是我创建博客站。12cd myblognpm install 访问URL我们可以运行看看Hexo创建的博客站是什么样的，运行以下命令 1hexo s 访问URL 1http://localhost:4000/ 好了，到这里你已经学会了通过Hexo创建博客了，接下来我们将会分析如何将我们的博客上传到我们的GitHub服务器上 上传到GitHubGitHub创建repositories进入GitHub官网,或者在浏览器输入https://github.com/,如果还没有账号就创建一个账号就好了，这里不教大家怎么注册账号了。登录自己的账号，直接点击new repositories或者进入You repositories再new repositories 进入到创建repositories页面来,这里很重要，一定要注意哦！必须将新建的repository的名字为: You account name.github.io。其他默认就好了 配置 注：repository: https://github.com/name/name.github.io.git 是自己刚刚创建You account name.github.io 的repository，在Clone with HTTPS里面，复制粘贴就好咯。冒号后面记得空格哦。branch 后面是master就好了。 GitHub的Repository创建好后。我们在回到本地的Hexo的Myblog项目中,找到在项目的根目录下_config.yml找到 deploy标签 在该文件下面添加 1234deploy: type: git repository: https://github.com/name/name.github.io.git #复制过来 branch: master 在_config.yml找到url进行修改为： 1url: http://name.github.io #假设name是我的账号，修改为自己的账号 部署到这里就差不到了，接下来我们需要执行一些命令，将我们的博客部署到GitHub上了，惊喜将会到来了。打开Git Bash Here进入myblog根目录下，首先我们需要安装一下hexo-deployer-git不然可能出现错误，无法部署成功，执行命令行。 1npm install hexo-deployer-git --save 然后在执行以下命令: 注：每次提交时必须执行这三个命令 123hexo cleanhexo generatehexo deploy 或者简写方式 123hexo cleanhexo ghexo d 测试我们进行访问https://name.github.io/和 http://localhost:4000/一样的页面说明是已经成功。 总结我们已经从如何使用Hexo到部署上GitHub上。需要我们对一些命令行的操作，还有一些需要我们必须注意的，一定要小心，不然就出错了。]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>Repositories</tag>
        <tag>Github</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx 配置 HTTPS]]></title>
    <url>%2F2018%2F12%2F31%2Fnginxsethttps%2F</url>
    <content type="text"><![CDATA[Nginx 配置 HTTPS 配置文件基本如下，请参考并进行相应的修改 123456789101112131415161718192021222324server &#123; listen 80; server_name domain.example.com ; #修改为自己的域名 rewrite ^(.*)`$ https://$`host$1 permanent; &#125;server &#123; listen 443; server_name domain.example.com; #修改为自己的域名 ssl on; root html; #html修改为网站的对应路径 index index.html index.htm; ssl_certificate cert/yourcrt.pem; #将证书添加到相应的文件夹 ssl_certificate_key cert/yourkey.key; #将密钥添加到相应的文件夹 ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; location / &#123; root html; #html修改为网站的对应路径 index index.html index.htm; &#125;&#125;]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos 设置静态 IP 联网]]></title>
    <url>%2F2018%2F12%2F31%2Fcentossetstaticnetwork%2F</url>
    <content type="text"><![CDATA[Centos 设置静态 IP 联网 第一步，我们进入/etc/sysconfig/network-scripts目录，查看该目录有没有形如ifcfg-XXX的文件： 如果你看不到以ifcfg-打头的文件（ifcfg-lo除外），说明网卡设备没有被正确识别，可能是你下载的centos镜像版本和你安装centos时选择的centos版本不一致，比如，centos镜像是64位的，却按照32位来安装。（ 建议重装 下面进行第二步： 在VMware里，依次点击”编辑“ - ”虚拟网络编辑器“，如下图，我选择的是NAT模式： 在这个界面接着点”NAT设置”，查看虚拟机的网关，这个网关在第三步要用。 第三步： 以root权限编辑/etc/sysconfig/network-scripts/ifcfg-ens33 #这边对应你自己的文件名 箭头指向的都修改位相应的模式 下方属性为对应添加的1234IPADDR=192.168.152.127 #设置时查看虚拟网络编辑器VMnet8下的DHCP设置，从起始IP地址开始分配GATEWAY=192.168.152.2 #刚刚前面查看的NAT设置的网关地址NETMASK=255.255.255.0 #这是子网掩码DNS1=114.114.114.114 #给服务器设置一个DNS服务器，这个为公用的一个服务器 最后重启网络配置1sevice network restart]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
</search>
